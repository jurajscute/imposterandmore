<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <title>Juraj's Impostor Game</title>

 <style>
    /* ... (All previous styles remain exactly the same) ... */
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; background: #f4f4f8; display: flex; justify-content: center; align-items: center; min-height: 100vh; color: #222; padding: 12px; }
    .container { width: 100%; max-width: 800px; min-width: 280px; padding: 16px 12px 24px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    h1 { text-align: center; margin: 0 0 8px; font-size: clamp(24px, 5vw, 32px); font-weight: 800; line-height: 1.2; padding: 0 8px; width: 100%; position: relative; }
    
    /* ... (Info Button, Instructions, Modal Styles remain the same) ... */
    .info-btn { position: absolute; right: 8px; top: 50%; transform: translateY(-50%); width: 36px; height: 36px; border-radius: 50%; background: linear-gradient(135deg, #4f46e5, #6366f1); color: white; border: none; font-size: 20px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3); transition: all 0.2s; }
    .info-btn:hover { transform: translateY(-50%) scale(1.1); box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4); }
    .info-btn:active { transform: translateY(-50%) scale(0.95); }
    @media (max-width: 480px) { .info-btn { width: 32px; height: 32px; font-size: 18px; right: 4px; } }
    p.instructions { margin: 0 0 20px; text-align: center; font-size: clamp(14px, 3.5vw, 16px); color: #555; line-height: 1.4; padding: 0 8px; max-width: 600px; width: 100%; }

    /* Modal Overlay & Content */
    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
    .modal-overlay.active { opacity: 1; visibility: visible; }
    .modal { background: white; border-radius: 20px; max-width: 700px; width: 100%; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); transform: translateY(20px); transition: transform 0.3s; }
    .modal-overlay.active .modal { transform: translateY(0); }
    .modal-header { padding: 24px 24px 16px; border-bottom: 2px solid #eef2ff; display: flex; justify-content: space-between; align-items: center; }
    .modal-header h2 { margin: 0; font-size: 24px; color: #4f46e5; font-weight: 800; }
    .close-btn { background: none; border: none; font-size: 28px; color: #666; cursor: pointer; width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background 0.2s; }
    .close-btn:hover { background: #f3f4f6; color: #dc2626; }
    .modal-content { padding: 24px; overflow-y: auto; flex: 1; }
    .modal-section { margin-bottom: 28px; }
    .modal-section h3 { margin: 0 0 16px; font-size: 20px; color: #333; font-weight: 700; padding-bottom: 8px; border-bottom: 2px solid #eef2ff; }
    .modal-section p { margin: 0 0 16px; line-height: 1.6; color: #444; }
    .modal-section ul, .modal-section ol { margin: 0 0 16px; padding-left: 24px; }
    .modal-section li { margin-bottom: 10px; line-height: 1.5; color: #444; }

    /* Form Styles */
    .form-group { margin-bottom: 20px; }
    .form-label { display: block; font-weight: 700; color: #374151; margin-bottom: 8px; font-size: 14px; }
    .form-input, .form-textarea { width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 10px; font-size: 15px; font-family: inherit; transition: border-color 0.2s; }
    .form-input:focus, .form-textarea:focus { outline: none; border-color: #4f46e5; }
    .form-textarea { min-height: 80px; resize: vertical; }
    .form-hint { font-size: 12px; color: #6b7280; margin-top: 6px; }

    /* Category Blocks */
    .category-block { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; margin-bottom: 16px; position: relative; }
    .category-block:hover { border-color: #d1d5db; }
    .remove-category-btn { position: absolute; top: 10px; right: 10px; background: #fee2e2; color: #dc2626; border: none; width: 28px; height: 28px; border-radius: 50%; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
    .remove-category-btn:hover { background: #fecaca; transform: scale(1.1); }
    .add-category-btn { width: 100%; padding: 12px; background: #eef2ff; color: #4f46e5; border: 2px dashed #c7d2fe; border-radius: 12px; font-weight: 700; cursor: pointer; margin-bottom: 20px; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; }
    .add-category-btn:hover { background: #e0e7ff; border-color: #818cf8; }

    /* Modal Footer */
    .modal-footer { padding: 16px 24px 24px; display: flex; justify-content: flex-end; gap: 12px; border-top: 1px solid #e5e7eb; flex-wrap: wrap; }
    .btn-secondary { padding: 12px 20px; background: #f3f4f6; color: #4b5563; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: background 0.2s; }
    .btn-secondary:hover { background: #e5e7eb; }
    .btn-primary { padding: 12px 20px; background: #4f46e5; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: background 0.2s; }
    .btn-primary:hover { background: #4338ca; }
    
    /* GITHUB BUTTON STYLE */
    .btn-github {
      padding: 12px 20px;
      background: #24292e;
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
      margin-right: auto; /* Pushes other buttons to the right */
    }
    .btn-github:hover { background: #1b1f23; }
    
    @media (max-width: 550px) {
      .modal-footer { justify-content: center; }
      .btn-github { margin-right: 0; width: 100%; justify-content: center; margin-bottom: 8px; }
      .btn-secondary, .btn-primary { flex: 1; }
    }

    /* ... (Role Grid, Cards, Slider, and Toggle styles remain the same) ... */
    .role-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 16px; margin-top: 16px; }
    @media (max-width: 700px) { .role-grid { grid-template-columns: 1fr; } }
    .role-card { background: #f9fafb; border-radius: 12px; padding: 20px; border-left: 4px solid #4f46e5; }
    .role-card.civilian { border-left-color: #3b82f6; } .civilian .role-icon { background: #3b82f6; }
    .role-card.imposter { border-left-color: #dc2626; } .imposter .role-icon { background: #dc2626; }
    .role-card.dictator { border-left-color: #dc2626; } .dictator .role-icon { background: #dc2626; }
    .role-card.mastermind { border-left-color: #dc2626; } .mastermind .role-icon { background: #dc2626; }
    .role-card.hunter { border-left-color: #dc2626; } .hunter .role-icon { background: #dc2626; }
    .role-card.detective { border-left-color: #10b981; } .detective .role-icon { background: #10b981; }
    .role-card.jester { border-left-color: #00a008; } .jester .role-icon { background: #00a008; }
    .role-card.jackal { border-left-color: #ff6600; } .jackal .role-icon { background: #ff6600; }
    .role-card.viper { border-left-color: #004b16; } .viper.role-icon { background: #004b16; }
    .role-card.shield { border-left-color: #0025a0; } .shield .role-icon { background: #0025a0; }
    .role-card.assassin { border-left-color: #8b5cf6; } .assassin .role-icon { background: #8b5cf6; }
    .role-card.king { border-left-color: #eab308; } .king .role-icon { background: linear-gradient(135deg, #eab308, #ca8a04); }
    .role-card.lovers { border-left-color: #ff7abc; } .lovers .role-icon { background: linear-gradient(135deg, #e874ff, #fdb4ff); }
    .role-card.clueless { border-left-color: #06b6d4; } .clueless .role-icon { background: #06b6d4; }
	  .role-card.echo { border-left-color: #6368ba; } .echo .role-icon { background: #6368ba; }
    .role-card.sheriff { border-left-color: #977d08; } .sheriff .role-icon { background: #977d08; }
    .role-card.idiot { border-left-color: #d9ff00; } .idiot .role-icon { background: #d9ff00; }
    .role-card.philosopher { border-left-color: #2b99ff; } .philosopher .role-icon { background: #2b99ff; }
    .role-card.maniac { border-left-color: #530000; } .maniac .role-icon { background: #530000; }
    .role-card.cultist { border-left-color: #c47070; } .cultist .role-icon { background: #c47070; }
    .role-card.shadow { border-left-color: #2b2b2b; } .shadow .role-icon { background: #2b2b2b; }
    hellos
    
    .role-card h4 { margin: 0 0 12px; font-size: 18px; font-weight: 700; color: #111; display: flex; align-items: center; gap: 8px; }
    .role-card .role-icon { width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; color: white; }
    .role-card p { margin: 0 0 12px; font-size: 15px; line-height: 1.5; color: #444; }
    .role-card .goal { font-weight: 600; color: #111; background: #eef2ff; padding: 8px 12px; border-radius: 8px; font-size: 14px; margin-top: 8px; }

    .subject-section { width: 100%; max-width: 500px; margin-bottom: 20px; background: #fff; padding: 20px; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
    .subject-section h2 { margin: 0 0 16px; text-align: center; font-size: clamp(18px, 4vw, 20px); color: #333; font-weight: 700; }
    .subject-options { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px; width: 100%; }
    @media (max-width: 500px) { .subject-options { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); } }
    .subject-option { padding: 14px 10px; border: 2px solid #e5e7eb; border-radius: 12px; background: #f9fafb; text-align: center; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; color: #4b5563; width: 100%; position: relative; }
    .subject-option:hover { background: #f3f4f6; transform: translateY(-2px); border-color: #d1d5db; }
    .subject-option.selected { background: #e0e7ff; border-color: #4f46e5; color: #4f46e5; box-shadow: 0 4px 8px rgba(79, 70, 229, 0.1); }
    .subject-option.add-new { border: 2px dashed #4f46e5; color: #4f46e5; background: #eef2ff; display: flex; align-items: center; justify-content: center; gap: 6px; }
    .subject-option.add-new:hover { background: #e0e7ff; }
    .delete-subject-btn { position: absolute; top: -6px; right: -6px; width: 22px; height: 22px; background: #ef4444; color: white; border-radius: 50%; border: 2px solid white; font-size: 14px; font-weight: bold; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.2s, transform 0.2s; }
    .subject-option:hover .delete-subject-btn { opacity: 1; }
    @media (hover: none) { .delete-subject-btn { opacity: 1; } }

    .custom-subject-container { margin-top: 16px; padding-top: 16px; border-top: 1px solid #e5e7eb; width: 100%; }
    .custom-subject-input { display: flex; gap: 10px; align-items: center; width: 100%; }
    @media (max-width: 480px) { .custom-subject-input { flex-direction: column; } }
    .custom-subject-input input { flex: 1; padding: 12px; font-size: 15px; border: 2px solid #ddd; border-radius: 10px; transition: border-color 0.2s; min-width: 0; }
    .custom-subject-input input:focus { outline: none; border-color: #4f46e5; }
    .custom-subject-btn { padding: 12px 20px; border: none; border-radius: 999px; background: linear-gradient(135deg, #10b981, #34d399); color: white; font-size: 14px; font-weight: 700; cursor: pointer; white-space: nowrap; transition: transform 0.12s ease, box-shadow 0.2s; box-shadow: 0 4px 8px rgba(16, 185, 129, 0.25); }
    @media (max-width: 480px) { .custom-subject-btn { width: 100%; } }
    .custom-subject-btn:hover { box-shadow: 0 6px 12px rgba(16, 185, 129, 0.3); }
    .custom-subject-btn:active { transform: scale(0.96); }

    .selected-subject-display { text-align: center; margin: 20px 0; padding: 16px; background: linear-gradient(135deg, #e0e7ff, #f3f4f6); border-radius: 14px; border: 2px solid #4f46e5; width: 100%; }
    .selected-subject-display h3 { margin: 0 0 8px; font-size: 16px; color: #6b7280; font-weight: 600; }
    .selected-subject-display .subject-name { font-size: clamp(20px, 4vw, 22px); font-weight: 800; color: #4f46e5; margin: 0; word-break: break-word; }
    .change-subject-btn { display: block; margin: 8px auto 0; padding: 8px 16px; border: none; border-radius: 999px; background: #f3f4f6; color: #6b7280; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; width: fit-content; }
    .change-subject-btn:hover { background: #e5e7eb; color: #4b5563; }

    .player-names-section { width: 100%; max-width: 500px; margin-bottom: 20px; background: #fff; padding: 20px; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); display: none; }
    .player-names-section h2 { margin: 0 0 16px; text-align: center; font-size: clamp(18px, 4vw, 20px); color: #333; font-weight: 700; }
    .player-names-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 2px solid #eef2ff; }
    .player-names-header h3 { margin: 0; font-size: 16px; color: #4f46e5; font-weight: 700; }
    .player-names-buttons { display: flex; gap: 8px; }
    .reset-names-btn { padding: 8px 16px; border: none; border-radius: 999px; background: #fee2e2; color: #dc2626; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap; }
    .reset-names-btn:hover { background: #fecaca; transform: translateY(-1px); }
    .player-names-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px; width: 100%; }
    @media (max-width: 500px) { .player-names-list { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); } }
    .player-name-input-container { display: flex; flex-direction: column; gap: 6px; position: relative; }
    .player-name-label { font-size: 13px; color: #6b7280; font-weight: 600; text-align: center; }
    .player-name-input { padding: 12px; font-size: 15px; border: 2px solid #ddd; border-radius: 10px; text-align: center; transition: border-color 0.2s; width: 100%; }
    .player-name-input:focus { outline: none; border-color: #4f46e5; }
    
    .player-count-controls { display: flex; flex-direction: column; gap: 12px; align-items: center; margin-bottom: 20px; padding: 16px; background: #f9fafb; border-radius: 12px; border: 2px solid #e5e7eb; width: 100%; }
    .player-count-label { font-size: 14px; font-weight: 600; color: #4b5563; text-align: center; }
    .count-buttons { display: flex; gap: 20px; align-items: center; justify-content: center; width: 100%; }
    .count-btn { width: 48px; height: 48px; border-radius: 50%; border: none; background: #e0e7ff; color: #4f46e5; font-size: 28px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; box-shadow: 0 2px 6px rgba(79, 70, 229, 0.2); }
    .count-btn:hover { background: #c7d2fe; transform: scale(1.1); box-shadow: 0 4px 8px rgba(79, 70, 229, 0.3); }
    .count-btn:active { transform: scale(0.95); }
    .count-btn.remove { background: #fee2e2; color: #dc2626; box-shadow: 0 2px 6px rgba(220, 38, 38, 0.2); }
    .count-btn.remove:hover { background: #fecaca; box-shadow: 0 4px 8px rgba(220, 38, 38, 0.3); }
    .player-count { font-size: 24px; font-weight: 800; color: #4f46e5; min-width: 50px; text-align: center; }
    .toggle-player-names { margin: 8px 0 0; padding: 8px 16px; border: none; border-radius: 999px; background: #e0e7ff; color: #4f46e5; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; width: fit-content; display: block; margin-left: auto; margin-right: auto; }
    .toggle-player-names:hover { background: #c7d2fe; transform: translateY(-1px); }

    .controls { display: flex; flex-direction: column; gap: 16px; align-items: center; justify-content: center; margin-bottom: 20px; background: #fff; padding: 20px; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); width: 100%; max-width: 500px; }
    .sliders-row { display: flex; flex-wrap: wrap; gap: 20px; width: 100%; justify-content: space-around; }
    .slider-container { display: flex; flex-direction: column; flex: 1; min-width: 140px; }
    .slider-label { font-size: 14px; color: #444; margin-bottom: 6px; font-weight: 600; text-align: center; display: flex; justify-content: space-between; align-items: center; }
    .slider-label span { font-weight: 800; color: #4f46e5; font-size: 16px; min-width: 24px; text-align: right; }
    .slider-wrapper { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
    .slider { flex: 1; height: 6px; -webkit-appearance: none; appearance: none; background: #e5e7eb; border-radius: 3px; outline: none; cursor: pointer; }
    .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 24px; height: 24px; border-radius: 50%; background: #4f46e5; cursor: pointer; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.2); transition: all 0.2s; }
    .slider::-webkit-slider-thumb:hover { transform: scale(1.1); box-shadow: 0 3px 8px rgba(0,0,0,0.3); }
    .slider-minmax { display: flex; justify-content: space-between; font-size: 12px; color: #6b7280; margin-top: 2px; }
    .slider-minmax span { font-weight: 600; }

    .roles-section { width: 100%; background: #f9fafb; border-radius: 12px; border: 1px solid #e5e7eb; padding: 12px; display: flex; flex-direction: column; align-items: center; gap: 12px; }
    .roles-section h3 { margin: 0 0 4px; font-size: 14px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 700; }
    .role-toggle { display: flex; align-items: center; justify-content: center; cursor: pointer; user-select: none; }
    .role-toggle.full-width { width: 100%; background: #eef2ff; border-radius: 8px; padding: 10px; border: 1px solid #e0e7ff; }
    .role-toggle.full-width label { width: 100%; display: flex; justify-content: center; gap: 10px; color: #4f46e5; font-weight: 700; }
    .roles-grid { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; width: 100%; }
    .role-pill { flex: 1 1 100px; max-width: 140px; background: white; border: 1px solid #ddd; border-radius: 8px; padding: 8px 6px; display: flex; justify-content: center; align-items: center; transition: all 0.2s; }
    .role-pill label { cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px; color: #444; font-weight: 600; margin: 0; width: 100%; justify-content: center; }
    .role-pill input[type="checkbox"] { margin: 0; width: 16px; height: 16px; cursor: pointer; }
    .role-pill:hover { background: #f3f4f6; }
    .role-pill.disabled { opacity: 0.5; pointer-events: none; background: #f3f4f6; }

    .btn { padding: 14px 24px; border: none; border-radius: 999px; background: linear-gradient(135deg, #4f46e5, #6366f1); color: white; font-size: 16px; font-weight: 700; cursor: pointer; width: 100%; max-width: 300px; text-align: center; transition: transform 0.12s ease, box-shadow 0.2s; box-shadow: 0 4px 12px rgba(79, 70, 229, 0.25); margin-top: 4px; }
    .btn:hover { box-shadow: 0 6px 16px rgba(79, 70, 229, 0.3); }
    .btn:active { transform: scale(0.96); }
    .btn:disabled { background: linear-gradient(135deg, #9ca3af, #d1d5db); cursor: not-allowed; box-shadow: none; transform: none; }
    
    .error { text-align: center; color: #dc2626; min-height: 20px; font-size: 14px; font-weight: 500; margin: 8px 0 16px; width: 100%; padding: 0 12px; max-width: 500px; }
    .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-top: 16px; width: 100%; max-width: 1000px; justify-items: center; }
    @media (max-width: 600px) { .cards { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; } }
    @media (max-width: 400px) { .cards { grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 8px; } }
    @media (max-width: 350px) { .cards { grid-template-columns: 1fr; max-width: 280px; } }
    .card { background: #fff; border-radius: 14px; padding: 14px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 8px; user-select: none; overflow: hidden; transition: transform 0.2s, box-shadow 0.2s; width: 100%; max-width: 200px; }
    @media (max-width: 600px) { .card { max-width: 180px; } }
    @media (max-width: 400px) { .card { max-width: 160px; padding: 12px; } }
    @media (max-width: 350px) { .card { max-width: 100%; } }
    .card:hover { transform: translateY(-2px); box-shadow: 0 6px 14px rgba(0,0,0,0.12); }
    .card-header { display: flex; justify-content: space-between; align-items: center; font-size: clamp(14px, 3vw, 16px); font-weight: 700; }
    .status-label { font-size: 11px; text-transform: uppercase; color: #777; font-weight: 600; letter-spacing: 0.5px; transition: color 0.15s; }
    
    .word-box { padding: 16px 10px; border-radius: 12px; border: 1px dashed #bbb; text-align: center; font-size: clamp(16px, 4vw, 20px); font-weight: 800; opacity: 0; transform: scale(0.9); transition: opacity 0.25s, transform 0.25s; min-height: 60px; display: flex; flex-direction: column; align-items: center; justify-content: center; word-break: break-word; overflow-wrap: break-word; width: 100%; }
    @media (max-width: 400px) { .word-box { min-height: 54px; padding: 12px 8px; } }
    .word-hidden { color: #777; }
    .word-revealed { color: #111; opacity: 1; transform: scale(1); }
    .word-locked { color: #999; font-style: italic; opacity: 1; transform: scale(1); font-size: 18px; }
    
    .detective-role { color: #10b981; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .imposter-role { color: #ff0000; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .dictator-role { color: #ff0000; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .mastermind-role { color: #ff0000; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }≈æ
    .hunter-role { color: #ff0000; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .jester-role { color: #00a008; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .jackal-role { color: #ff6600; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .viper-role { color: #004b16; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .shield-role { color: #0025a0; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .assassin-role { color: #8b5cf6; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .king-role { color: #d97706; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .lovers-role { color: #ff78b7; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
	  .echo-role { color: #6368ba; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .sheriff-role { color: #977d08; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .idiot-role { color: #d6c800; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .philosopher-role { color: #2b99ff; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .maniac-role { color: #530000; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .cultist-role { color: #c47070; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    .shadow-role { color: #2b2b2b; font-size: 14px; font-weight: 700; margin-top: 4px; text-align: center; line-height: 1.3; }
    
    .category-box { padding: 10px 12px; border-radius: 10px; background: #eef2ff; text-align: center; font-size: clamp(14px, 3.5vw, 16px); font-weight: 600; opacity: 0; transform: translateY(-10px); transition: opacity 0.25s, transform 0.25s; min-height: 44px; display: flex; align-items: center; justify-content: center; word-break: break-word; width: 100%; }
    @media (max-width: 400px) { .category-box { min-height: 40px; padding: 8px 10px; } }
    .category-shown { opacity: 1; transform: translateY(0); }
    
    .card-btn { padding: 12px 14px; border-radius: 999px; border: none; background: #e5e7eb; font-size: 15px; font-weight: 700; cursor: pointer; width: 100%; transition: all 0.2s; color: #333; margin-top: 4px; }
    .card-btn:active { transform: scale(0.96); }
    .card-btn.locked { background: #d1d5db; color: #6b7280; cursor: default; transform: none; opacity: 0.8; }
    
    .imposter-hint, .dictator-hint, .mastermind-hint, .hunter-hint, .detective-hint, .assassin-hint, .jester-hint, .jackal-hint, .viper-hint, .shield-hint, .king-hint, .lovers-hint, .sheriff-hint, .echo-hint, .idiot-hint, .philosopher-hint, .maniac-hint, .cultist-hint, .shadow-hint { font-size: 13px; font-weight: 600; margin-top: 6px; text-align: center; padding: 8px; border-radius: 8px; border: 1px solid; line-height: 1.4; opacity: 0; transform: translateY(10px); transition: opacity 0.25s, transform 0.25s; }
    .detective-hint { color: #10b981; background: #f0fdf4; border-color: #bbf7d0; }
    .imposter-hint { color: #ff0000; background: #ffd2d2; border-color: #ff0000; }
    .dictator-hint { color: #ff0000; background: #ffd2d2; border-color: #ff0000; }
    .mastermind-hint { color: #ff0000; background: #ffd2d2; border-color: #ff0000; }
    .hunter-hint { color: #ff0000; background: #ffd2d2; border-color: #ff0000; }
    .assassin-hint { color: #8b5cf6; background: #f5f3ff; border-color: #ddd6fe; }
    .jester-hint { color: #00a008; background: #d7ffd4; border-color: #00a008; }
    .jackal-hint { color: #ff6600; background: #ffe5d4; border-color: #ff6600; }
    .viper-hint { color: #004b16; background: #9cc597; border-color: #004b16; }
    .shield-hint { color: #0025a0; background: #e0e0ff; border-color: #0025a0; }
    .king-hint { color: #d97706; background: #fefce8; border-color: #fde047; }
    .lovers-hint { color: #ff78b7; background: #ffdcf2; border-color: #ff78b7; }
    .echo-hint { color: #6368ba; background: #d0dbff; border-color: #4338ca; }
    .sheriff-hint { color: #977d08; background: #fff4b9; border-color: #977d08; }
    .idiot-hint { color: #d6c800; background: #f1f8b16e; border-color: #d6c800; }
    .philosopher-hint { color: #2b99ff; background: #d0eeff; border-color: #3d81ff; }
    .maniac-hint { color: #530000; background: #ffe0e0; border-color: #790000; }
    .cultist-hint { color: #c47070; background: #ffefef; border-color: #c47070; }
    .shadow-hint { color: #2b2b2b; background: #e2e2e2; border-color: #202020; }
    .imposter-hint.show, .dictator-hint.show, .mastermind-hint.show, .hunter-hint.show, .detective-hint.show, .assassin-hint.show, .jester-hint.show, .jackal-hint.show, .viper-hint.show, .shield-hint.show, .king-hint.show, .lovers-hint.show, .echo-hint.show, .sheriff-hint.show, .idiot-hint.show, .philosopher-hint.show, .maniac-hint.show, .cultist-hint.show, .shadow-hint.show { opacity: 1; transform: translateY(0); }
    
    .status-section { margin-top: 28px; width: 100%; max-width: 500px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    .reveal-tracker { text-align: center; margin-bottom: 20px; font-size: clamp(16px, 4vw, 20px); font-weight: 800; color: #4f46e5; min-height: 32px; padding: 16px; background: #fff; border-radius: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 100%; }
    .first-player { text-align: center; padding: 20px 16px; background: linear-gradient(135deg, #4f46e5, #8b5cf6); color: white; border-radius: 18px; font-size: clamp(18px, 5vw, 24px); font-weight: 900; opacity: 0; transform: translateY(20px); transition: opacity 0.5s, transform 0.5s; box-shadow: 0 6px 20px rgba(79, 70, 229, 0.4); width: 100%; line-height: 1.3; margin-bottom: 16px; }
    .first-player.show { opacity: 1; transform: translateY(0); }
    .reveal-roles-btn { padding: 14px 24px; border: none; border-radius: 999px; background: linear-gradient(135deg, #f59e0b, #fbbf24); color: white; font-size: 16px; font-weight: 700; cursor: pointer; width: 100%; max-width: 300px; text-align: center; transition: transform 0.12s ease, box-shadow 0.2s; box-shadow: 0 4px 12px rgba(245, 158, 11, 0.25); margin-bottom: 16px; }
    .reveal-roles-btn:hover { box-shadow: 0 6px 16px rgba(245, 158, 11, 0.3); }
    .reveal-roles-btn:active { transform: scale(0.96); }
    .reveal-roles-btn:disabled { background: linear-gradient(135deg, #9ca3af, #d1d5db); cursor: not-allowed; box-shadow: none; transform: none; }
    
    .king-announcement { text-align: center; padding: 20px 16px; background: linear-gradient(135deg, #eab308, #ca8a04); color: white; border-radius: 18px; font-size: clamp(16px, 4vw, 20px); font-weight: 700; opacity: 0; transform: translateY(20px); transition: opacity 0.5s, transform 0.5s; box-shadow: 0 6px 20px rgba(234, 179, 8, 0.4); width: 100%; line-height: 1.4; margin-bottom: 16px; }
    .king-announcement.show { opacity: 1; transform: translateY(0); }

    .lovers-announcement { text-align: center; padding: 20px 16px; background: linear-gradient(135deg, #ff3d87, #ff78b7); color: white; border-radius: 18px; font-size: clamp(16px, 4vw, 20px); font-weight: 700; opacity: 0; transform: translateY(20px); transition: opacity 0.5s, transform 0.5s; box-shadow: 0 6px 20px rgba(234, 8, 121, 0.4); width: 100%; line-height: 1.4; margin-bottom: 16px; }
    .lovers-announcement.show { opacity: 1; transform: translateY(0); }
    
    .roles-reveal-box { text-align: center; padding: 0; background: #fff; color: #222; border-radius: 16px; font-size: clamp(16px, 4vw, 18px); font-weight: 600; opacity: 0; transform: translateY(20px); transition: opacity 0.5s, transform 0.5s; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 100%; line-height: 1.4; margin-bottom: 16px; max-height: 0; overflow: hidden; border: 2px solid #4f46e5; }
    /* FIXED SCROLLING HERE */
    .roles-reveal-box.show { opacity: 1; transform: translateY(0); max-height: 600px; overflow-y: auto; transition: opacity 0.5s, transform 0.5s, max-height 0.5s; }
    .roles-reveal-header { padding: 20px 16px; background: linear-gradient(135deg, #87adff, #7679ff); color: white; border-radius: 14px 14px 0 0; margin: 0; }
    .roles-reveal-header h3 { margin: 0; font-size: clamp(18px, 4vw, 22px); font-weight: 800; }
    .roles-reveal-content { padding: 20px; }
    .role-list { text-align: left; margin: 0; padding: 0; list-style: none; }
    .role-list li { margin-bottom: 12px; padding: 14px 16px; background: #f9fafb; border-radius: 12px; font-size: 15px; display: flex; justify-content: space-between; align-items: center; transition: transform 0.2s, box-shadow 0.2s; border-left: 4px solid #4f46e5; }
    .role-list li:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
    .role-list .player-number { font-weight: 800; margin-right: 10px; color: #4f46e5; font-size: 16px; min-width: 80px; }
    .role-list .role-name { font-weight: 600; padding: 6px 12px; border-radius: 8px; background: #eef2ff; color: #4f46e5; font-size: 14px; flex: 1; text-align: center; }
    .role-list .civilian-role { background: #e0e7ff; color: #3b82f6; border-left-color: #3b82f6; }
    .role-list .imposter-role { background: #fee2e2; color: #dc2626; border-left-color: #dc2626; }
    .role-list .dictator-role { background: #fee2e2; color: #dc2626; border-left-color: #dc2626; }
    .role-list .mastermind-role { background: #fee2e2; color: #dc2626; border-left-color: #dc2626; }
    .role-list .hunter-role { background: #fee2e2; color: #dc2626; border-left-color: #dc2626; }
    .role-list .detective-role { background: #d1fae5; color: #10b981; border-left-color: #10b981; }
    .role-list .jester-role { background: #caffcd; color: #00a008; border-left-color: #00a008; }
    .role-list .jackal-role { background: #ffe5d4; color: #ff6600; border-left-color: #ff6600; }
    .role-list .viper-role { background: #9cc597; color: #004b16; border-left-color: #004b16; }
    .role-list .shield-role { background: #e0e0ff; color: #0025a0; border-left-color: #0025a0; }
    .role-list .assassin-role { background: #f5f3ff; color: #8b5cf6; border-left-color: #8b5cf6; }
    .role-list .king-role { background: #fefce8; color: #d97706; border-left-color: #eab308; }
    .role-list .lovers-role { background: #fee8f2; color: #ff78b7; border-left-color: #ff3d87; }
    .role-list .clueless-role { background: #ecfeff; color: #0891b2; border-left-color: #0891b2; }
    .role-list .echo-role { background: #d0cbff; color: #6368ba; border-left-color: #6368ba; }
    .role-list .sheriff-role { background: #fff4b9; color: #977d08; border-left-color: #977d08; }
    .role-list .idiot-role { background: #f1f8b16e; color: #d6c800; border-left-color: #d6c800; }
    .role-list .philosopher-role { background: #d0eeff; color: #2b99ff; border-left-color: #2b99ff; }
    .role-list .maniac-role { background: #ffe0e0; color: #530000; border-left-color: #530000; }
    .role-list .cultist-role { background: #ffefef; color: #c47070; border-left-color: #c47070; }
    .role-list .shadow-role { background: #e2e2e2; color: #2b2b2b; border-left-color: #2b2b2b; }
    .assassin-target { font-size: 12px; color: #8b5cf6; font-weight: 600; margin-top: 4px; background: rgba(139, 92, 246, 0.1); padding: 4px 8px; border-radius: 6px; display: inline-block; }
    .king-badge { font-size: 12px; color: #d97706; font-weight: 600; margin-top: 4px; background: rgba(234, 179, 8, 0.1); padding: 4px 8px; border-radius: 6px; display: inline-block; }
    .lovers-badge { font-size: 12px; color: #ff78b7; font-weight: 600; margin-top: 4px; background: rgba(234, 8, 147, 0.1); padding: 4px 8px; border-radius: 6px; display: inline-block; }
    .clueless-word-display { font-size: 12px; color: #0891b2; font-weight: 600; margin-top: 4px; background: rgba(6, 182, 212, 0.1); padding: 4px 8px; border-radius: 6px; display: inline-block; }
    .footer-note { margin-top: 24px; text-align: center; font-size: 13px; color: #666; padding: 0 12px; line-height: 1.5; max-width: 500px; width: 100%; }
  /* AI Button Style */
.subject-option.ai-generate {
  border: 2px dashed #f43f5e;
  color: #f43f5e;
  background: #fff1f2;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}
.subject-option.ai-generate:hover {
  background: #ffe4e6;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(244, 63, 94, 0.2);
}

.role-pill {
  transition: all 0.2s ease;
  border: 2px solid transparent;
  position: relative;
  z-index: 1;
}

/* ENABLED */
.role-pill.enabled {
  opacity: 1;
}

/* DISABLED */
.role-pill.disabled {
  opacity: 0.45;
  filter: grayscale(40%);
}

/* Glow using pseudo element (does NOT affect layout) */
.role-pill.enabled::after {
  content: "";
  position: absolute;
  inset: -3px;
  border-radius: 10px;
  pointer-events: none;
  z-index: -1;
}
/* ===== WIN SCREEN BASE ===== */
.win-header {
  padding: 30px;
  border-radius: 20px 20px 0 0;
  font-weight: bold;
  animation: fadeIn 0.6s ease;
}

.win-content {
  padding: 25px;
  border-radius: 0 0 20px 20px;
}

.role-reveal {
  font-weight: bold;
  text-shadow: 0 0 8px currentColor;
}

/* Poison screen header */
.poison-header {
  animation: fadeIn 0.4s ease;
}

/* Subtext */
.poison-subtext {
  font-size: 14px;
  opacity: 0.8;
  margin-top: 6px;
}

/* Poison buttons slightly tinted */
.poison-btn {
  border: 2px solid #2bff88;
  box-shadow: 0 0 8px rgba(43,255,136,0.4);
}

/* üêç Poison Button Style */
.poison-btn {
  border: 2px solid #00ff66;
  color: #00ff66;
  background: rgba(0, 255, 100, 0.08);
  box-shadow: 0 0 8px rgba(0,255,100,0.6);
  transition: all 0.25s ease;
}

.poison-btn:hover {
  background: rgba(0,255,100,0.2);
  box-shadow: 0 0 18px rgba(0,255,100,1);
  transform: scale(1.05);
}

/* Glowing poison word */
.poison-text {
  color: #00ff66;
  text-shadow: 0 0 8px #00ff66, 0 0 16px #00ff66;
}

.start-voting-btn {
  opacity: 0;
  transition: opacity 0.3s ease;
}

.start-voting-btn.show {
  opacity: 1;
}

.lover-death-message {
  margin-top: 15px;
  padding: 15px;
  border-radius: 12px;
  background: linear-gradient(135deg, #ffe4e6, #fecdd3);
  text-align: center;
  animation: loverFade 0.6s ease;
}

.dictator-screen {
  background: linear-gradient(135deg, #8b0000, #ff0000);
  border-radius: 12px;
  padding: 20px;
  color: white;
}

.dictator-screen .roles-reveal-header {
  background: linear-gradient(135deg, #8b0000, #ff0000);
}

.dictator-screen {
  box-shadow: 0 0 25px rgba(255, 0, 0, 0.6);
}

.mastermind-vision {
  margin-top: 10px;
  padding: 10px;
  background: linear-gradient(135deg, #1a0000, #4d0000);
  border-radius: 10px;
  font-size: 13px;
  max-height: 160px;
  overflow-y: auto;
  box-shadow: 0 0 12px rgba(255, 0, 0, 0.6);
  color: white;
}

.mastermind-player-role {
  padding: 4px 0;
  border-bottom: 1px solid rgba(255,255,255,0.15);
}

.word-box .hunter-role {
  color: #ff0000;
  font-size: 14px;
  font-weight: 700;
}

@keyframes loverFade {
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
}

.main-evil:has(input:checked) {
  box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
  border: 2px solid #ff0000;
}

poison-death.poison-death {
  color: #600dad;
  font-style: italic;
}

/* ===== SHERIFF SCREEN ===== */

.sheriff-header {
  text-align: center;
  padding: 20px;
  background: linear-gradient(135deg, #1e293b, #0f172a);
  border-radius: 12px;
  margin-bottom: 15px;
  color: #facc15;
  box-shadow: 0 0 20px rgba(250, 204, 21, 0.3);
}

.sheriff-content {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
  margin-top: 15px;
  width: 100%;
}

.sheriff-footer {
  margin-top: 15px;
  text-align: center;
}

.sheriff-warning {
  font-style: italic;
  color: #f87171;
  font-size: 14px;
}

.sheriff-btn {
  background: linear-gradient(135deg, #facc15, #eab308);
  color: black;
  font-weight: bold;
}

.sheriff-btn {
  width: 100%;
  padding: 14px 0;
  border-radius: 30px;
  text-align: center;
}

.sheriff-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 0 15px rgba(250, 204, 21, 0.6);
}

.sheriff-header {
  animation: sheriffGlow 2s ease-in-out infinite alternate;
}

.sheriff-content button:last-child:nth-child(odd) {
  grid-column: 1 / -1;   /* span both columns */
  justify-self: center;  /* center it */
}

/* üî• Skip always centered below */
.sheriff-skip {
  grid-column: 1 / -1;   /* span both columns */
  justify-self: center;  /* center horizontally */
  max-width: 250px;      /* optional: make it slightly smaller */
}

@keyframes sheriffGlow {
  from { box-shadow: 0 0 10px rgba(250,204,21,0.3); }
  to   { box-shadow: 0 0 25px rgba(250,204,21,0.7); }
}

/* Optional subtle pulse */
@keyframes poisonPulse {
  0% { box-shadow: 0 0 8px rgba(0,255,100,0.5); }
  50% { box-shadow: 0 0 18px rgba(0,255,100,1); }
  100% { box-shadow: 0 0 8px rgba(0,255,100,0.5); }
}

.poison-btn {
  animation: poisonPulse 2s infinite;
}

/* Smooth reappear animation */
@keyframes voteFadeIn {
  from {
    opacity: 0;
    transform: translateY(15px) scale(0.98);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.vote-fade-in {
  animation: voteFadeIn 0.35s ease;
}

/* Continue Button Press */
@keyframes continuePress {
  0% { transform: scale(1); }
  50% { transform: scale(0.95); }
  100% { transform: scale(1); }
}

.continue-animate {
  animation: continuePress 0.25s ease;
}

/* Fade Results Out */
@keyframes resultsFade {
  from { opacity: 1; }
  to { opacity: 0; }
}

.fade-results {
  animation: resultsFade 0.3s ease forwards;
}

/* Vote Click Pop */
@keyframes votePop {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.1); }
  100% { transform: scale(0.95); opacity: 0.7; }
}

.vote-locked {
  animation: votePop 0.25s ease forwards;
}

/* Fade Between Voters */
@keyframes fadeSlideOut {
  from { opacity: 1; transform: translateX(0); }
  to   { opacity: 0; transform: translateX(-15px); }
}

.fade-out-vote {
  animation: fadeSlideOut 0.25s ease forwards;
}

/* Fade Out Animation */
@keyframes fadeOutBtn {
  from { opacity: 1; transform: scale(1); }
  to   { opacity: 0; transform: scale(0.95); }
}

#revealRolesBtn.fade-out {
  animation: fadeOutBtn 0.4s ease forwards;
}
/* ===== Glow Pulse ===== */
@keyframes glowPulse {
  0% { box-shadow: 0 0 10px currentColor; }
  50% { box-shadow: 0 0 30px currentColor; }
  100% { box-shadow: 0 0 10px currentColor; }
}

/* ===== Gradient Shift ===== */
@keyframes gradientShift {
  0%   { background-position: 0% 50%; }
  50%  { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
} 
/* ===== Fade In ===== */
@keyframes fadeIn {
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
}

/* ===== Full Screen Shield Flash ===== */

#shieldFlashOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;

  background: radial-gradient(
    circle at center,
    rgba(255,255,255,0.85) 0%,
    rgba(120,200,255,0.75) 40%,
    rgba(0,120,255,0.6) 70%,
    rgba(0,0,0,0) 100%
  );

  opacity: 0;
}

/* Flash animation */
@keyframes shieldFullFlash {
  0% {
    opacity: 0;
  }
  40% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

.shield-flash-active {
  animation: shieldFullFlash 0.7s ease-out forwards;
}
  </style>
</head>

<body>
<div class="container">

  <h1>
    Juraj's Impostor Game
    <button class="info-btn" id="infoBtn">i</button>
  </h1>
  <p class="instructions">
    You get a word + category. Imposters see the category, too.<br>
    Cards can only be opened once.
  </p>

  <div class="modal-overlay" id="modalOverlay">
    <div class="modal">
      <div class="modal-header">
        <h2>How to Play Imposter Game</h2>
        <button class="close-btn" id="closeModalBtn">&times;</button>
      </div>
      <div class="modal-content">
        
        <div class="modal-section">
          <h3>Rules</h3>
          <ol>
            <li><strong>Setup:</strong> Choose a subject, number of players, and imposters</li>
            <li><strong>Secret Word:</strong> All players get a secret word from the chosen subject</li>
            <li><strong>Category:</strong> Everyone also sees the category of the secret word</li>
            <li><strong>Imposters:</strong> Some players are imposters - they DON'T know the secret word!</li>
            <li><strong>Discussion:</strong> Players discuss to figure out who the imposters are by saying a word related to the secret word they got</li>
            <li><strong>Voting:</strong> Vote to eliminate suspected imposters</li>
            <li><strong>Winning:</strong> Civilians win if all impostors, the viper and the jackal are eliminated. Impostors win if they survive, same with Jackal and Viper. Jester wins if he/she gets voted out. Assassin wins if their target gets voted out. King gets 2 votes. If lovers both make it to the end and complete atleast one of their goals they win.</li>
          </ol>
        </div>
        
        <div class="modal-section">
          <h3>Cards</h3>
          <div class="role-grid">
            <div class="role-card civilian"><h4><span class="role-icon">üó∏</span>Civilian</h4><p>You know the secret word. Goal: Eliminate imposters.</p><div class="goal">Goal: Eliminate imposters</div></div>
            <div class="role-card imposter"><h4><span class="role-icon">ü©∏</span>Imposter</h4><p>You DON'T know the secret word! Pretend you know it.</p><div class="goal">Goal: Don't get eliminated</div></div>
            <div class="role-card dictator"><h4><span class="role-icon">‚öúÔ∏è</span>Dictator</h4><p>You DON'T know the secret word! Everyones roles are in your disposal, you can see what role anyone is!</p><div class="goal">Goal: Don't get eliminated</div></div>
            <div class="role-card mastermind"><h4><span class="role-icon">üß†</span>Mastermind</h4><p>You DON'T know the secret word! You are able to remove anyones vote once per vote!</p><div class="goal">Goal: Don't get eliminated</div></div>
            <div class="role-card hunter"><h4><span class="role-icon">üèπ</span>Hunter</h4><p>You DON'T know the secret word! Choose a player after getting your role and later on decide what to do with your prey.</p><div class="goal">Goal: Don't get eliminated</div></div>
            <div class="role-card detective"><h4><span class="role-icon">üîç</span>Detective</h4><p>You can peek at one random player's role.</p><div class="goal">Goal: Help civilians</div></div>
            <div class="role-card jester"><h4><span class="role-icon">üÉè</span>Jester</h4><p>You want to get voted out.</p><div class="goal">Goal: Get voted out</div></div>
            <div class="role-card jackal"><h4><span class="role-icon">üî™</span>Jackal</h4><p>You DON'T know the secret word! Pretend you know it and outlive the impostor.</p><div class="goal">Goal: Don't get eliminated</div></div>
            <div class="role-card viper"><h4><span class="role-icon">üêç</span>Viper</h4><p>You DON'T know the secret word! Your votes don't count BUT you're able to poison 1 person per meeting and they will die by the next!</p><div class="goal">Goal: Don't get eliminated</div></div>
            <div class="role-card shield"><h4><span class="role-icon">üõ°Ô∏è</span>Shield</h4><p>Defend yourself if you're being voted! You can choose to vote out 1 person who voted for you.</p><div class="goal">Goal: Eliminate impostors, defend yourself!</div></div>
            <div class="role-card assassin"><h4><span class="role-icon">üó°Ô∏è</span>Assassin</h4><p>Eliminate your target.</p><div class="goal">Goal: Get target voted out</div></div>
            <div class="role-card king"><h4><span class="role-icon">üëë</span>King</h4><p>You get 2 votes.</p><div class="goal">Goal: Survive and complete your goals!</div></div>
            <div class="role-card lovers"><h4><span class="role-icon">ü©∑</span>Lovers</h4><p>You have a partner!</p><div class="goal">Goal: Use extra vote wisely</div></div>
            <div class="role-card clueless"><h4><span class="role-icon">?</span>Clueless</h4><p>You get the wrong word.</p><div class="goal">Goal: Figure out you are clueless</div></div>
            <div class="role-card echo"><h4><span class="role-icon">üîä</span>Echo</h4><p>You have to base your answers purely from the person before you. Like an echo.</p><div class="goal">Goal: Eliminate impostors, don't reveal your role.</div></div>
            <div class="role-card sheriff"><h4><span class="role-icon">üåµ</span>Sheriff</h4><p>You have the option to eliminate someone! Be careful, with great power comes great responsibility.</p><div class="goal">Goal: Eliminate impostors, by any means necessary.</div></div>
            <div class="role-card idiot"><h4><span class="role-icon">üêî</span>Idiot</h4><p>You have no idea what the word is.</p><div class="goal">Goal: Eliminate impostors.</div></div>
            <div class="role-card philosopher"><h4><span class="role-icon">üí≠</span>Philosopher</h4><p>You are able to ask a single Yes or No question, the target must answer it honestly (Unless they're a jester!).</p><div class="goal">Goal: Eliminate impostors, question your enemies.</div></div>
            <div class="role-card maniac"><h4><span class="role-icon">üí¢</span>Maniac</h4><p>Help the impostor win, but without using a vote!</p><div class="goal">Goal: Win with the Impostor.</div></div>
            <div class="role-card cultist"><h4><span class="role-icon">ü™¨</span>Cultist</h4><p>Worship your unknown leader!</p><div class="goal">Goal: Win with the Impostor.</div></div>
            <div class="role-card shadow"><h4><span class="role-icon">üêà‚Äç‚¨õ</span>Shadow</h4><p>Figure out the word and help the impostor!</p><div class="goal">Goal: Win with the Impostor.</div></div>
          </div>
        </div>

        leoniscool.com

      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="aiModalOverlay">
  <div class="modal">
    <div class="modal-header">
      <h2>‚ú® AI Subject Generator</h2>
      <button class="close-btn" id="closeAiModalBtn">&times;</button>
    </div>
    <div class="modal-content">
      <p style="text-align:center; color:#666; margin-bottom: 20px;">
        Enter a topic and AI will create a category and word list for you instantly.
      </p>
      
      <div class="form-group">
        <label class="form-label" for="aiTopicInput">Topic / Theme</label>
        <input type="text" id="aiTopicInput" class="form-input" placeholder="e.g. Harry Potter, 90s Rappers, obscure cheeses...">
      </div>

      <div class="modal-footer">
        <button class="btn-secondary" id="cancelAiBtn">Cancel</button>
        <button class="btn-primary" id="generateAiBtn" style="background: linear-gradient(135deg, #f43f5e, #e11d48);">
          <span>‚ö°</span> Generate
        </button>
      </div>
      
      <div id="aiStatus" style="text-align:center; margin-top:10px; color:#666; font-size:14px; min-height:20px;"></div>
    </div>
  </div>
</div>

  <div class="modal-overlay" id="createSubjectOverlay">
    <div class="modal">
      <div class="modal-header">
        <h2>Create Custom Subject</h2>
        <button class="close-btn" id="closeCreateSubjectBtn">&times;</button>
      </div>
      <div class="modal-content">
        <div class="form-group">
          <label class="form-label" for="newSubjectName">Subject Name</label>
          <input type="text" id="newSubjectName" class="form-input" placeholder="e.g. My Custom Game">
        </div>
        
        <div id="categoriesContainer">
          </div>

        <button class="add-category-btn" id="addCategoryBtn">
          <span>+</span> Add Category
        </button>

        <div class="modal-footer">
          <button class="btn-github" id="submitGithubBtn">
            <svg height="20" width="20" viewBox="0 0 16 16" fill="white" style="display: block;">
              <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
            Submit to GitHub
          </button>
          <button class="btn-secondary" id="cancelCreateSubjectBtn">Cancel</button>
          <button class="btn-primary" id="saveSubjectBtn">Save Subject</button>
        </div>
      </div>
    </div>
  </div>

  <div class="subject-section" id="subjectSection">
    <h2>Choose a Subject</h2>
    
    <div id="subjectDisplay" class="selected-subject-display" style="display: none;">
      <h3>Selected Subject:</h3>
      <div class="subject-name" id="selectedSubjectName"></div>
      <button class="change-subject-btn" id="changeSubjectBtn">Change Subject</button>
    </div>
    
    <div id="subjectSelection">
      <div class="subject-options" id="subjectOptions">
        </div>
      
      <div class="custom-subject-container">
        <div class="custom-subject-input">
          <input type="text" id="customSubjectInput" placeholder="Quick single word/phrase...">
          <button class="custom-subject-btn" id="customSubjectBtn">Use Once</button>
        </div>
      </div>
    </div>
  </div>

  <div class="player-names-section" id="playerNamesSection">
    <h2>Customize Player Names</h2>
    <div class="player-names-header">
      <h3>Players (Click to Edit)</h3>
      <div class="player-names-buttons">
        <button class="reset-names-btn" id="resetNamesBtn">Reset</button>
      </div>
    </div>
    <div class="player-names-list" id="playerNamesList"></div>
    <div class="player-count-controls">
      <div class="player-count-label">Number of Players</div>
      <div class="count-buttons">
        <button class="count-btn remove" id="removePlayerBtn">‚àí</button>
        <div class="player-count" id="playerCountDisplay">3</div>
        <button class="count-btn" id="addPlayerBtn">+</button>
      </div>
    </div>
    <button class="toggle-player-names" id="hidePlayerNamesBtn">Hide Player Names</button>
  </div>

  <div class="controls">
    
    <div class="sliders-row">
      <div class="slider-container">
        <div class="slider-label">
          Players
          <span id="playersValue">3</span>
        </div>
        <div class="slider-wrapper">
          <input type="range" id="playerSlider" class="slider" min="3" max="20" value="3">
        </div>
        <div class="slider-minmax">
          <span>3</span>
          <span>20</span>
        </div>
      </div>

      <div class="slider-container">
        <div class="slider-label">
          Impostors
          <span id="impostersValue">1</span>
        </div>
        <div class="slider-wrapper">
          <input type="range" id="imposterSlider" class="slider" min="1" max="10" value="1">
        </div>
        <div class="slider-minmax">
          <span>1</span>
          <span>10</span>
        </div>
      </div>
    </div>

<div class="roles-section">
  <h3>Special Roles</h3>

  <div class="role-toggle randomize-toggle full-width">
    <label>
      <input id="randomizeToggle" type="checkbox">
      Randomize Roles
    </label>
  </div>
  <!-- ================= IMPOSTORS ================= -->
   <h4 class="role-category">Impostors</h4>
  <div class="roles-grid">

    <div class="role-pill main-evil" id="imposterContainer">
      <label>
        <input id="imposterToggle" type="checkbox" name="imposter">
        Imposter
      </label>
    </div>

    <div class="role-pill main-evil" id="dictatorContainer">
      <label>
        <input id="dictatorToggle" type="checkbox" name="dictator">
        Dictator
      </label>
    </div>

    <div class="role-pill main-evil" id="mastermindContainer">
      <label>
        <input id="mastermindToggle" type="checkbox" name="mastermind">
        Mastermind
      </label>
    </div>

     <div class="role-pill main-evil" id="hunterContainer">
      <label>
        <input id="hunterToggle" type="checkbox" name="hunter">
        Hunter
      </label>
    </div>

  </div>

  <!-- ================= CREW ================= -->
  <h4 class="role-category">Crew</h4>
  <div class="roles-grid">
    
    <div class="role-pill philosopher-toggle" id="philosopherContainer">
      <label>
        <input id="philosopherToggle" type="checkbox" name="philosopher">
        Philosopher
      </label>
    </div>

    <div class="role-pill detective-toggle" id="detectiveContainer">
      <label>
        <input id="detectiveToggle" type="checkbox" name="detective">
        Detective
      </label>
    </div>

    <div class="role-pill clueless-toggle" id="cluelessContainer">
      <label>
        <input id="cluelessToggle" type="checkbox" name="clueless">
        Clueless
      </label>
    </div>

    <div class="role-pill echo-toggle" id="echoContainer">
      <label>
        <input id="echoToggle" type="checkbox" name="echo">
        Echo
      </label>
    </div>

    <div class="role-pill sheriff-toggle" id="sheriffContainer">
      <label>
        <input id="sheriffToggle" type="checkbox" name="sheriff">
        Sheriff
      </label>
    </div>

    <div class="role-pill idiot-toggle" id="idiotContainer">
      <label>
        <input id="idiotToggle" type="checkbox" name="idiot">
        Idiot
      </label>
    </div>

    <div class="role-pill shield-toggle" id="shieldContainer">
      <label>
        <input id="shieldToggle" type="checkbox" name="shield">
        Shield
      </label>
    </div>

  </div>

  <!-- ================= EVIL ================= -->
  <h4 class="role-category">Evil</h4>
  <div class="roles-grid">

    <div class="role-pill shadow-toggle" id="shadowContainer">
      <label>
        <input id="shadowToggle" type="checkbox" name="shadow">
        Shadow
      </label>
    </div>

    <div class="role-pill maniac-toggle" id="maniacContainer">
      <label>
        <input id="maniacToggle" type="checkbox" name="maniac">
        Maniac
      </label>
    </div>

    <div class="role-pill cultist-toggle" id="cultistContainer">
      <label>
        <input id="cultistToggle" type="checkbox" name="cultist">
        Cultist
      </label>
    </div>

  </div>

  <!-- ================= NEUTRAL ================= -->
  <h4 class="role-category">Neutral</h4>
  <div class="roles-grid">

    <div class="role-pill jester-toggle" id="jesterContainer">
      <label>
        <input id="jesterToggle" type="checkbox" name="jester">
        Jester
      </label>
    </div>

    <div class="role-pill jackal-toggle" id="jackalContainer">
      <label>
        <input id="jackalToggle" type="checkbox" name="jackal">
        Jackal
      </label>
    </div>

    <div class="role-pill viper-toggle" id="viperContainer">
      <label>
        <input id="viperToggle" type="checkbox" name="viper">
        Viper
      </label>
    </div>

    <div class="role-pill assassin-toggle" id="assassinContainer">
      <label>
        <input id="assassinToggle" type="checkbox" name="assassin">
        Assassin
      </label>
    </div>

  </div>

  <!-- ================= ADD ONS ================= -->
  <h4 class="role-category">Add Ons</h4>
  <div class="roles-grid">

    <div class="role-pill king-toggle" id="kingContainer">
      <label>
        <input id="kingToggle" type="checkbox" name="king">
        King
      </label>
    </div>

    <div class="role-pill lovers-toggle" id="loversContainer">
      <label>
        <input id="loversToggle" type="checkbox" name="lovers">
        Lovers
      </label>
    </div>

  </div>

</div>

    <button id="generateBtn" class="btn" disabled>Deal Cards</button>
    <button class="toggle-player-names" id="showPlayerNamesBtn">Customize Player Names</button>
  </div>

  <div id="error" class="error"></div>
  
  <div id="cardsContainer" class="cards"></div>
  
  <div class="status-section">
    <div id="revealTracker" class="reveal-tracker"></div>
    <div id="kingAnnouncement" class="king-announcement"></div>
    <div id="firstPlayer" class="first-player"></div>
    <button id="revealRolesBtn" class="reveal-roles-btn" style="display: none;">Reveal All Roles</button>
    <div id="rolesRevealBox" class="roles-reveal-box"></div>
  </div>

<button id="startVotingBtn" class="btn start-voting-btn" style="display:none;">
  Start Voting
</button>

<div id="votingBox" class="roles-reveal-box"></div>

  <div class="footer-note">
    Close your card before passing the device.
  </div>
  <div class="footer-note">
    leoniscool.com
  </div>

</div>

<script>

// AI Modal Elements
const aiModalOverlay = document.getElementById("aiModalOverlay");
const closeAiModalBtn = document.getElementById("closeAiModalBtn");
const cancelAiBtn = document.getElementById("cancelAiBtn");
const generateAiBtn = document.getElementById("generateAiBtn");
const aiTopicInput = document.getElementById("aiTopicInput");
const aiStatus = document.getElementById("aiStatus");

/* ====== GAME STATE ===== */
let currentSubject = "";
let actualCustomSubject = ""; // Stores the actual custom word
let customItems = [];
let totalCards = 0;
let revealedCards = 0;
let lockedCards = 0;
let playerNumbers = [];
let words = []; // Store words globally for detective peek
let secretItem = ""; // Store secret item globally for detective
let secretCategory = ""; // Store secret category globally for detective
let assassinTarget = null; // Store assassin's target
let playerNames = []; // Store custom player names
let kingPlayer = null; // Store which player is king (index)
let loverIndexes = [];
let cluelessWord = ""; // Store the wrong word given to the clueless player
let imposterIndex = null;
let players = [];
let currentVoterIndex = 0;
let votes = {};

let viperAnnouncedPoison = null; // announced but not yet killed
let poisonedTarget = null;
let viperChoosingPoison = false;
let viperNextPoison = null;     // selected this meeting
let viperActivePoison = null;   // kills NEXT meeting
let meetingMessages = "";
let viperCooldown = false; // true = refueling, cannot poison

let sheriffAllowedRoles = ["Imposter", "Dictator", "Mastermind", "Hunter", "Jackal", "Assassin", "Viper", "Maniac", "Cultist", "Shadow"]; // roles Sheriff can kill safely
let dictatorBlockedPlayer = null;

let sheriffShotTarget = null;

let hunterPendingKill = null;
let hunterChoosingIndex = null;
let hunterMarkedTarget = null;
let isHunterChoosing = false;

// NEW: State for detective interaction
let isDetectiveChoosing = false;
let activeDetectiveCardElement = null;
let activeDetectiveHintElement = null;

// NEW: Saved Custom Subjects
let savedCustomSubjects = {};

/* ===== ELEMENTS ===== */
const cardsContainer = document.getElementById("cardsContainer");
const generateBtn = document.getElementById("generateBtn");
const errorBox = document.getElementById("error");
const revealTracker = document.getElementById("revealTracker");
const firstPlayerBox = document.getElementById("firstPlayer");
const revealRolesBtn = document.getElementById("revealRolesBtn");
const rolesRevealBox = document.getElementById("rolesRevealBox");
const subjectSection = document.getElementById("subjectSection");
const subjectOptions = document.getElementById("subjectOptions");
const subjectDisplay = document.getElementById("subjectDisplay");
const subjectSelection = document.getElementById("subjectSelection");
const selectedSubjectName = document.getElementById("selectedSubjectName");
const changeSubjectBtn = document.getElementById("changeSubjectBtn");
const customSubjectInput = document.getElementById("customSubjectInput");
const customSubjectBtn = document.getElementById("customSubjectBtn");
const kingAnnouncement = document.getElementById("kingAnnouncement");


// Slider elements
const playerSlider = document.getElementById("playerSlider");
const imposterSlider = document.getElementById("imposterSlider");
const playersValue = document.getElementById("playersValue");
const impostersValue = document.getElementById("impostersValue");

// Player names elements
const playerNamesSection = document.getElementById("playerNamesSection");
const playerNamesList = document.getElementById("playerNamesList");
const resetNamesBtn = document.getElementById("resetNamesBtn");
const hidePlayerNamesBtn = document.getElementById("hidePlayerNamesBtn");
const showPlayerNamesBtn = document.getElementById("showPlayerNamesBtn");

// Add/Remove player elements
const addPlayerBtn = document.getElementById("addPlayerBtn");
const removePlayerBtn = document.getElementById("removePlayerBtn");
const playerCountDisplay = document.getElementById("playerCountDisplay");

// Role toggle elements
const randomizeToggle = document.getElementById("randomizeToggle");
const detectiveToggle = document.getElementById("detectiveToggle");
const imposterToggle = document.getElementById("imposterToggle");
const dictatorToggle = document.getElementById("dictatorToggle");
const mastermindToggle = document.getElementById("mastermindToggle");
const hunterToggle = document.getElementById("hunterToggle");
const jesterToggle = document.getElementById("jesterToggle");
const jackalToggle = document.getElementById("jackalToggle");
const viperToggle = document.getElementById("viperToggle");
const shieldToggle = document.getElementById("shieldToggle");
const assassinToggle = document.getElementById("assassinToggle");
const kingToggle = document.getElementById("kingToggle");
const loversToggle = document.getElementById("loversToggle");
const cluelessToggle = document.getElementById("cluelessToggle");
const echoToggle = document.getElementById("echoToggle");
const sheriffToggle = document.getElementById("sheriffToggle");
const idiotToggle = document.getElementById("idiotToggle");
const philosopherToggle = document.getElementById("philosopherToggle");
const maniacToggle = document.getElementById("maniacToggle");
const cultistToggle = document.getElementById("cultistToggle");
const shadowToggle = document.getElementById("shadowToggle");

// Role colors
const roleColors = {
  "Imposter": "#dc2626",
  "Dictator": "#dc2626",
  "Mastermind": "#dc2626",
  "Hunter": "#dc2626",
  
  "Maniac": "#530000",
  "Cultist": "#c47070",
  "Shadow": "#2b2b2b",

  "Detective": "#10b981",
  "Philosopher": "#2b99ff",
  "Clueless": "#06b6d4",
  "Echo": "#6368ba",
  "Sheriff": "#977d08",
  "Idiot": "#d9ff00",
  "Shield": "#0025a0",

  "Jackal": "#ff6600",
  "Viper": "#004b16",
  "Jester": "#00a008",
  "Assassin": "#8b5cf6",

  "Lovers": "#ff7abc",
  "King": "#eab308",

  "Crew": "#3b82f6"
};

// Role themes
const roleThemes = {
  Crew: "#3b82f6",
  Imposter: "#e74c3c",
  Dictator: "#e74c3c",
  Mastermind: "#e74c3c",
  Hunter: "#e74c3c",
  Jackal: "#ff6600",
  Viper: "#004b16",
  Assassin: "#9b59b6",
  Jester: "#00a008",
  Lovers: "#ff7abc"
};

const mainEvilRoles = ["Imposter", "Dictator", "Mastermind", "Hunter"];

const roleData = {
  detective:  { team: "Crew" },
  sheriff:    { team: "Crew" },
  shield:     { team: "Crew" },
  philosopher:{ team: "Crew" },
  echo:       { team: "Crew" },
  clueless:   { team: "Crew" },
  idiot:      { team: "Crew" },

  imposter:   { team: "Evil" },
  dictator:   { team: "Evil" },
  mastermind:   { team: "Evil" },
  hunter:   { team: "Evil" },

  maniac:     { team: "Evil" },
  cultist:     { team: "Evil" },
  shadow:     { team: "Evil" },

  jackal:     { team: "Neutral" },
  viper:      { team: "Neutral" },
  assassin:   { team: "Neutral" },
  jester:     { team: "Neutral" }
};

// Containers for visual disabling
const imposterContainer = document.getElementById("imposterContainer");
const dictatorContainer = document.getElementById("dictatorContainer");
const mastermindContainer = document.getElementById("mastermindContainer");
const hunterContainer = document.getElementById("hunterContainer");
const detectiveContainer = document.getElementById("detectiveContainer");
const jesterContainer = document.getElementById("jesterContainer");
const jackalContainer = document.getElementById("jackalContainer");
const viperContainer = document.getElementById("viperContainer");
const shieldContainer = document.getElementById("shieldContainer");
const assassinContainer = document.getElementById("assassinContainer");
const kingContainer = document.getElementById("kingContainer");
const loversContainer = document.getElementById("loversContainer");
const cluelessContainer = document.getElementById("cluelessContainer");
const echoContainer = document.getElementById("echoContainer");
const idiotContainer = document.getElementById("idiotContainer");
const philosopherContainer = document.getElementById("philosopherContainer");
const sheriffContainer = document.getElementById("sheriffContainer");
const maniacContainer = document.getElementById("maniacContainer");
const cultistContainer = document.getElementById("cultistContainer");
const shadowContainer = document.getElementById("shadowContainer");

// Modal elements
const infoBtn = document.getElementById("infoBtn");
const modalOverlay = document.getElementById("modalOverlay");
const closeModalBtn = document.getElementById("closeModalBtn");

// Create Subject Modal Elements
const createSubjectOverlay = document.getElementById("createSubjectOverlay");
const closeCreateSubjectBtn = document.getElementById("closeCreateSubjectBtn");
const cancelCreateSubjectBtn = document.getElementById("cancelCreateSubjectBtn");
const saveSubjectBtn = document.getElementById("saveSubjectBtn");
const submitGithubBtn = document.getElementById("submitGithubBtn"); // New GitHub Button
const newSubjectNameInput = document.getElementById("newSubjectName");
const categoriesContainer = document.getElementById("categoriesContainer");
const addCategoryBtn = document.getElementById("addCategoryBtn");

/* ===== AI GENERATOR FUNCTIONS ===== */
function openAiModal() {
  aiTopicInput.value = "";
  aiStatus.textContent = "";
  generateAiBtn.disabled = false;
  generateAiBtn.innerHTML = "<span>‚ö°</span> Generate";
  aiModalOverlay.classList.add('active');
  aiTopicInput.focus();
}

function closeAiModal() {
  aiModalOverlay.classList.remove('active');
}

async function fetchAiResponse(messages, onComplete) {
  try {
    const response = await fetch('https://text.pollinations.ai/openai/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        model: 'openai', 
        messages: messages, 
        stream: false, 
        temperature: 0.1, // Low creativity for consistent JSON
        max_tokens: 350
      }),
    });
    const data = await response.json();
    const text = data.choices[0].message.content;
    if(onComplete) onComplete(text);
  } catch (e) {
    console.error(e);
    aiStatus.textContent = "Network error. Please try again.";
    generateAiBtn.disabled = false;
    generateAiBtn.innerHTML = "<span>‚ö°</span> Generate";
  }
}

function safeJsonParse(str) {
  try {
    let clean = str.replace(/```json/g, "").replace(/```/g, "").trim();
    return JSON.parse(clean);
  } catch (e) {
    // Attempt to fix unclosed array
    try {
      let clean = str.replace(/```json/g, "").replace(/```/g, "").trim();
      if(!clean.endsWith(']')) clean += ']';
      return JSON.parse(clean); 
    } catch(e2) { return null; }
  }
}

function generateAiSubject() {
  const topic = aiTopicInput.value.trim();
  if (!topic) {
    aiStatus.textContent = "Please enter a topic.";
    return;
  }

  generateAiBtn.disabled = true;
  generateAiBtn.innerHTML = "<span>‚è≥</span> Thinking...";
  aiStatus.textContent = "Consulting the oracle...";

  // Optimized prompt for flat array
  const prompt = `Topic: "${topic}".
    Return a single JSON Array containing 16 strings.
    Index 0 is a Creative Title for this category.
    Index 1-15 are related words for the game.
    Example: ["Space Things", "Sun", "Moon", "Stars"...]
    No markdown.`;

  const messages = [
    { role: "system", content: "Output RAW JSON Array only." },
    { role: "user", content: prompt }
  ];

  fetchAiResponse(messages, (rawText) => {
    const data = safeJsonParse(rawText);
    
    if (!Array.isArray(data) || data.length < 5) {
      aiStatus.textContent = "AI got confused. Try a simpler topic.";
      generateAiBtn.disabled = false;
      generateAiBtn.innerHTML = "<span>‚ö°</span> Generate";
      return;
    }

    const subjectName = data[0]; // Title
    const words = data.slice(1); // Items

    // 1. Save to Custom Subjects Structure
    // Structure: { "Subject Name": { "Category Name": [words] } }
    const newSubjectData = {};
    newSubjectData[subjectName] = words; // Using SubjectName as CategoryName for simplicity
    
    savedCustomSubjects[subjectName] = newSubjectData;
    localStorage.setItem("savedCustomSubjects", JSON.stringify(savedCustomSubjects));

    // 2. Refresh UI and Select
    closeAiModal();
    initializeSubjectOptions(); // Re-render list
    selectSubject(subjectName); // Auto-select the new one
  });
}

/* ===== DEFAULT SUBJECTS ===== */
const defaultSubjects = {
  "Clash Royale": {
    troops: ["Archers","Archer Queen","Baby Dragon","Balloon","Bandit","Barbarians","Bats","Battle Healer","Battle Ram",
      "Berserker","Bomber","Boss Bandit","Bowler","Bush Goblins","Cannon Cart","Cursed Hog","Dark Prince","Dart Goblin",
      "Electro Dragon","Electro Giant","Electro Spirit","Electro Wizard","Elite Barbarians","Elixir Blob","Elixir Golem",
      "Elixir Golemite","Executioner","Firecracker","Fire Spirit","Fisherman","Flying Machine","Furnace","Giant",
      "Giant Skeleton","Goblin Brawler","Goblin Gang","Goblin Demolisher","Goblin Giant","Goblin Machine","Goblins",
      "Goblinstein","Golden Knight","Golem","Golemite","Guardienne","Guards","Hog Rider","Hunter","Heal Spirit",
      "Ice Golem","Ice Spirit","Ice Wizard","Inferno Dragon","Knight","Lava Hound","Lava Pup","Little Prince","Lumberjack",
      "Magic Archer","Mega Knight","Mega Minion","Mighty Miner","Miner","Mini P.E.K.K.A.","Minion Horde","Minions",
      "Monk","Mother Witch","Monster","Musketeer","Night Witch","P.E.K.K.A.","Phoenix","Prince","Princess","Ram Rider",
      "Rascal Boy","Rascal Girl","Royal Ghost","Royal Giant","Royal Hogs","Royal Recruits","Rune Giant","Skeleton Army",
      "Skeleton Barrel","Skeleton Dragons","Skeleton King","Skeletons","Sparky","Spear Goblins","Spirit Empress",
      "Suspicious Bush","Three Musketeers","Valkyrie","Wall Breakers","Witch","Wizard","Zappies"
    ],
    
    buildings: ["Bomb Tower","Cannon","Inferno Tower","Mortar","Tesla","X-Bow","Barbarian Hut","Elixir Collector",
      "Goblin Cage","Goblin Drill","Goblin Hut","Tombstone"
    ],
    
    spells: ["Arrows","Barbarian Barrel","Earthquake","Fireball","Freeze","Giant Snowball","Goblin Curse","Lightning",
      "Poison","Rage","Rocket","Royal Delivery","The Log","Tornado","Vines","Void","Zap"
    ]
  },
  
  "Physics": {
    kinematics: ["Displacement","Velocity","Acceleration","Free Fall","Projectile Motion","Kinematic Equations","Constant Acceleration","Position-Time Graph","Velocity-Time Graph"],
    forces: ["Newton's First Law","Newton's Second Law","Newton's Third Law","Force","Mass","Weight","Friction","Normal Force","Tension","Net Force","Inertia","Equilibrium","Free Body Diagram","Air Resistance", "F=ma"],
    energy: ["Kinetic Energy","Potential Energy","Conservation of Energy","Work","Power","Mechanical Energy","Thermal Energy","Energy Transfer","Work-Energy Theorem","Efficiency","Gravitational Energy","Spring Energy","Elastic Energy","Hooke's Law","Simple Machines","Energy Loss"],
    momentum: ["Linear Momentum","Impulse","Conservation of Momentum","Elastic Collision","Inelastic Collision","Center of Mass","Momentum Transfer","Recoil","Explosion","Momentum Vector","Elastic Bounce","Inelastic Bounce","Perfectly Inelastic","Angular Momentum"],
    circular: ["Centripetal Force","Centripetal Acceleration","mv^2/r", "v^2/r"],
    fluids: ["Density","Pressure","Buoyancy","Archimedes' Principle","Bernoulli's Principle","Continuity Equation","Fluid Flow","Laminar Flow","Viscosity","Hydraulic Lift","Pascal's Law","Hydrostatic Pressure","Streamlines","Flow Rate","Turbulent Flow"],
    rotation: ["Angular Acceleration","Angular Momentum","Inertia","Center of Mass", "Rotational Kinetic Energy", "Rotational Kinematics"],
    shm: ["Periodic Motion","Frequency","Amplitude","Phase","Restoring Force","Spring Oscillation","Pendulum Oscillation","Resonance"],
    thermo: ["Temperature","Heat Transfer","Conduction","Convection","Radiation","Internal Energy","Specific Heat","Thermal Equilibrium"],
    electricity: ["Charge","Electric Field","Voltage","Current","Resistance","Ohm's Law","Power","Series Circuit","Parallel Circuit","Circuit Diagram"],
    gravity: ["Gravitational Constant","Gravitational Force","mg","Kepler's 3rd law"]
  },
  
  "Math": {
    algebra: ["Variable","Expression","Equation","Inequality","Linear Equation","Quadratic Equation","Polynomial","Factoring","Completing the Square","Exponential Function","Logarithmic Function","Rational Expression","System of Equations","Matrix","Vector","Function","Domain","Range"],
    geometry: ["Point","Line","Plane","Angle","Congruent","Similarity","Triangle","Pythagorean Theorem","Circle","Radius","Diameter","Chord","Arc","Central Angle","Inscribed Angle","Area","Perimeter","Volume","Surface Area"],
    trigonometry: ["Sine","Cosine","Tangent","Unit Circle","Radians","Degrees","Pythagorean Identity","Law of Sines","Law of Cosines","Trigonometric Graphs","Amplitude","Period","Phase Shift","Inverse Trig Function"],
    precalculus: ["Sequence","Series","Arithmetic Sequence","Geometric Sequence","Binomial Theorem","Polynomial Division","Rational Function","Asymptote","Complex Number","Imaginary Unit"],
    statistics: ["Mean","Median","Mode","Range","Standard Deviation","Variance","Probability","Combination","Permutation","Normal Distribution","Outlier","Correlation"]
  },

  "Calculus": {
    limits: ["Limit","Continuity","One-Sided Limit","Infinite Limit","Limit Laws","Indeterminate Form","Removable Discontinuity","Jump Discontinuity","Vertical Asymptote","Horizontal Asymptote","Squeeze Theorem","L'H√¥pital's Rule"],
    derivatives: ["Derivative","Differentiability","Tangent Line","Instantaneous Rate","Power Rule","Sum Rule","Difference Rule","Product Rule","Quotient Rule","Chain Rule","Implicit Differentiation","Higher Derivative","Second Derivative","Third Derivative","Inverse Function","Logarithmic Differentiation","Exponential Derivative","Trig Derivative"],
    applicationsOfDerivatives: ["Critical Point","Local Maximum","Local Minimum","First Derivative Test","Second Derivative Test","Inflection Point","Concave Up","Concave Down","Optimization","Related Rates","Velocity Function","Acceleration Function","Motion on a Line","Mean Value Theorem"],
    integrals: ["Antiderivative","Indefinite Integral","Definite Integral","Constant of Integration","Net Change","Area Under Curve","Riemann Sum","Trapezoidal Rule","Accumulation Function","Average Value","U-Substitution"],
    applicationsOfIntegrals: ["Differential Equation","Separation of Variables","Initial Condition","Rate of Change","Motion with Acceleration","Distance and Displacement","Growth and Decay"],
    theorems: ["Fundamental Theorem of Calculus","Mean Value Theorem","Rolle's Theorem"]
  },
  
  "Computer Science": {
    programmingBasics: ["Variable","Constant","Data Type","Integer","Float","Boolean","String","Expression","Statement","Comment","Indentation"],
    basicCommands: ["If Statement","Else Statement","Else If","Comparison Operator","Logical Operator","For Loop","While Loop","Break","Continue","Iteration","Recursion"],
    functions: ["Function","Parameter","Argument","Return Value","Scope","Local Variable","Global Variable","Function Call","Function Definition"],
    dataStructures: ["Array","List","Tuple","Dictionary","Object","Stack","Queue","Set","Linked List","Tree","Binary Tree","Graph","Hash Table","Pointer","Node"],
    algorithms: ["Searching","Linear Search","Binary Search","Sorting","Bubble Sort","Selection Sort","Insertion Sort","Merge Sort","Quick Sort","Time Complexity","Space Complexity","Big O Notation","Recursion","Divide and Conquer"],
    ai: ["Machine Learning","Neural Network","Training","Testing","Dataset","Supervised Learning","Unsupervised Learning","Classification","Regression","Accuracy","Precision","Recall","Overfitting","Underfitting"],
    languages: ["Python","Java","JavaScript","C","C++","C#","Scratch","SQL","HTML","CSS"]
  },

  "Animals": {
    mammals: ["Lion","Elephant","Dolphin","Kangaroo","Panda","Giraffe","Tiger","Wolf","Bear","Monkey"],
    birds: ["Eagle","Penguin","Peacock","Owl","Hummingbird","Parrot","Flamingo","Swan","Woodpecker","Kingfisher"],
    reptiles: ["Crocodile","Komodo Dragon","Chameleon","Iguana","Gecko","Turtle","Snake","Alligator","Monitor Lizard","Tortoise"],
    aquatic: ["Shark","Octopus","Jellyfish","Starfish","Seahorse","Whale","Dolphin","Squid","Crab","Lobster"],
    insects: ["Butterfly","Dragonfly","Ladybug","Ant","Bee","Spider","Beetle","Grasshopper","Mantis","Firefly"]
  },
  
  "Fruits": {
    citrus: ["Orange","Lemon","Lime","Grapefruit","Tangerine","Clementine","Kumquat","Pomelo","Yuzu","Ugli Fruit"],
    tropical: ["Mango","Pineapple","Coconut","Papaya","Dragon Fruit","Passion Fruit","Guava","Lychee","Rambutan","Durian"],
    berries: ["Strawberry","Blueberry","Raspberry","Blackberry","Cranberry","Gooseberry","Elderberry","Boysenberry","Mulberry","Acai Berry"],
    stone: ["Peach","Plum","Cherry","Apricot","Nectarine","Mango","Lychee","Date","Olive","Coconut"],
    melons: ["Watermelon","Cantaloupe","Honeydew","Galia","Canary","Santa Claus","Crenshaw","Sharlyn","Casaba","Sprite"]
  },
  
  "Countries": {
    europe: ["France","Germany","Italy","Spain","United Kingdom","Greece","Netherlands","Sweden","Switzerland","Norway"],
    asia: ["Japan","China","India","South Korea","Thailand","Vietnam","Indonesia","Philippines","Malaysia","Singapore"],
    americas: ["United States","Canada","Brazil","Mexico","Argentina","Chile","Peru","Colombia","Cuba","Jamaica"],
    africa: ["Egypt","South Africa","Kenya","Morocco","Nigeria","Ghana","Tanzania","Ethiopia","Uganda","Rwanda"],
    oceania: ["Australia","New Zealand","Fiji","Papua New Guinea","Samoa","Tonga","Vanuatu","Solomon Islands","Kiribati","Micronesia"]
  },
  
  "Sports": {
    ball: ["Basketball","Soccer","Football","Baseball","Tennis","Volleyball","Golf","Rugby","Cricket","Handball"],
    water: ["Swimming","Surfing","Water Polo","Diving","Rowing","Sailing","Canoeing","Kayaking","Water Skiing","Synchronized Swimming"],
    winter: ["Skiing","Snowboarding","Ice Hockey","Figure Skating","Bobsleigh","Curling","Biathlon","Luge","Speed Skating","Freestyle Skiing"],
    combat: ["Boxing","Wrestling","Martial Arts","Fencing","Judo","Taekwondo","Karate","MMA","Kendo","Sumo"],
    individual: ["Gymnastics","Athletics","Cycling","Archery","Weightlifting","Triathlon","Equestrian","Shooting","Badminton","Table Tennis"]
  },
  
   "Names": {
    name: ["Leon","Matteo","Illay","Carver","Ethan","Naoki","Thomas","Sean","Luke", "Nico"]
  },
  
  "Minecraft": {
    mobs: ["Villager","Cow","Pig","Chicken","Sheep","Wolf","Horse","Cat","Fox","Bee","Rabbit","Parrot","Llama","Zombie","Skeleton","Creeper","Spider","Enderman","Slime","Witch","Phantom","Pillager","Blaze","Ghast","Piglin","Hoglin","Guardian","Evoker","Vex","Warden","Ender Dragon","Wither"],
    blocks: ["Stone","Dirt","Sand","Gravel","Wood","Leaves","Glass","Obsidian","Clay","Bricks","Netherrack","End Stone","Basalt","Deepslate","Bedrock"],
    resources: ["Coal","Iron","Gold","Diamond","Emerald","Redstone","Lapis","Copper","Nether Quartz","Ancient Debris"],
    items: ["Sword","Axe","Pickaxe","Shovel","Bow","Shield","Trident","Fishing Rod","Compss","Clock","Shears","Map"],
    food: ["Bread","Steak","Cooked Porkchop","Cooked Chicken","Baked Potato","Carrot","Apple","Melon","Chorus Fruit","Golden Apple","Pumpkin Pie","Honey Bottle"],
    structures: ["Village","Temple","Stronghold","Mineshaft","Ocean Monument","Ruined Portal","Nether Fortress","Bastion","End City","Ancient City"],
    biomes: ["Plains","Forest","Taiga","Jungle","Desert","Savanna","Swamp","Mountains","Snowy Biome","Ocean","Badlands","Mushroom Biome","Nether","End"],
    toolsAndGear: ["Pickaxe","Sword","Axe","Hoe","Shovel","Armor","Helmet","Chestplate","Leggings","Boots","Shield","Crossbow"],
    magicAndPotions: ["Enchanting Table","Potion of Healing","Potion of Strength","Potion of Swiftness","Potion of Fire Resistance","Potion of Regeneration","Potion of Invisibility","Potion of Slow Falling"]
  },

  "Geometry Dash": {
    levels: ["Stereo Madness","Back on Track","Polargeist","Dry Out","Base After Base","Can't Let Go","Jumper","Time Machine","Cycles","xStep","Clutterfunk","Theory of Everything","Electroman Adventures","Geometrical Dominator","Hexagon Force","Blast Processing","Electrodynamix","Clubstep","Theory of Everything 2","Deadlocked","ORBIT","LIMBO","Bloodbath","Top 10","Bloodshower","Purpular Rectanglisi (mer green)","Sonic Wave","Change of Scene","Absolute Garbage","HOW","WHAT","Grass","Nagatabi","Sunrise","Night City"],
    gamemodes: ["Cube","Robot","Ship","Ball","Wave","Spider","UFO","Swing Copter"],
    structures: ["Ekirby8 Tower","Clubstep Monster","Triple Spike"]
  },

  "Objects": {
    objects: ["Chair","Table","Sofa","Bed","Lamp","Mirror","Clock","Pillow","Blanket","Curtain","Candle","TV","Remote","Shelf","Plate","Cup","Fork","Knife","Spoon","Pan","Pot","Bottle","Microwave","Fridge","Toaster","Phone","Laptop","Tablet","Headphones","Charger","Mouse","Keyboard","Camera","Smartwatch","Speaker","Notebook","Pencil","Pen","Eraser","Ruler","Backpack","Calculator","Binder","Shirt","Pants","Jacket","Hat","Socks","Shoes","Gloves","Belt","Hammer","Screwdriver","Wrench","Pliers","Drill","Saw","Tape Measure","Car","Bike","Bus","Train","Scooter","Motorcycle","Airplane","Boat","Wallet","Keys","Water Bottle","Backpack","Trash Can","Umbrella","Broom","Mop","Vacuum","Toothbrush","Toothpaste","Soap","Shampoo","Comb","Hairdryer","Sunglasses","Watch","Notebook","Stapler","Paperclip","Highlighter","Glue","Scissors"]
  },

  "School Food": {
    lunch: ["Pizza","Chicken Waffles","Salad","Pasta","Burrito","Quesadilla","Rice Bowl","Grilled Cheese","Hamburger"],
    sides: ["Apple Sauce","Craisins", "Milk", "Carrots"],
    brunch: ["Granola Bar", "Yogurt", "Pancake", "Muffin", "Burrito", "Bagel"]
  },
  
    "Engineering": {
    civilEngineering: [
      "Bridge",
      "Overloading",
      "Tension",
      "Compression",
      "Beam",
      "Civil Engineer",
      "Suspension Bridge",
      "Triangles",
      "Truss Bridge",
      "Arch Bridge"
    ],

    aerospaceEngineering: [
      "Wing",
      "Drag",
      "Gravity",
      "Thrust",
      "Lift",
      "Sonic Boom",
      "Nose",
      "Touchdown",
      "Rocket",
      "Atmosphere"
    ],

    bioChemicalEngineering: [
      "Mixture",
      "DNA",
      "Solution",
      "Heat",
      "Periodic Table",
      "Gas",
      "Liquid",
      "Metal",
      "Nonmetal",
      "Reaction",
      "Pipette"
    ],

    randomEngineering: [
      "Inertia",
      "Gears",
      "Frictionless Surface",
      "Welding",
      "AI",
      "Bearing",
      "Counterweight",
      "CAD",
      "3D Printing"
    ]
  },

  "Questions": {
    question: ["Most likely to become rich","Most likely to become famous","Most likely to start a business","Most likely to win a Nobel Prize","Most likely to drop out of school","Most likely to go to jail","Most likely to become a comedian","Most likely to become a teacher","Most likely to travel the world","Most likely to live alone forever","Most likely to have 10 pets","Most likely to win the lottery","Most likely to become a millionaire before 30","Most likely to start a YouTube channel","Most likely to become a pro athlete","Most likely to become a doctor","Most likely to become president","Most likely to join the military","Most likely to become a lawyer","Most likely to date a celebrity","Most likely to forget their own birthday","Most likely to forget where they live","Most likely to cry during a movie","Most likely to start a fight","Most likely to fall asleep in class","Most likely to get lost in their own neighborhood","Most likely to laugh at their own joke","Most likely to survive a zombie apocalypse","Most likely to die first in a horror movie","Most likely to crash their car","Most likely to be late to their own wedding","Most likely to have 10 kids","Most likely to become a billionaire","Most likely to donate millions to charity","Most likely to go skydiving","Most likely to get a weird tattoo","Most likely to eat something off the floor","Most likely to forget their homework","Most likely to get expelled","Most likely to get the highest GPA","Most likely to be class clown","Most likely to skip school","Most likely to live in another country","Most likely to become a model","Most likely to become an influencer","Most likely to invent something","Most likely to win a game show","Most likely to run a marathon","Most likely to become a scientist","Most likely to go bald early","Most likely to get plastic surgery","Most likely to own a yacht","Most likely to own a private jet","Most likely to own a mansion","Most likely to go bankrupt","Most likely to disappear and never return","Most likely to be the teacher's pet"]
  }
};

/* ===== LOCAL STORAGE LOAD ===== */
// Load slider values
playerSlider.value = localStorage.getItem("playerCount") || 3;
imposterSlider.value = localStorage.getItem("imposterCount") || 1;
currentSubject = localStorage.getItem("currentSubject") || "";
actualCustomSubject = localStorage.getItem("actualCustomSubject") || "";
customItems = JSON.parse(localStorage.getItem("customItems")) || [];

// Load toggle states
detectiveToggle.checked = JSON.parse(localStorage.getItem("detectiveEnabled")) || false;
jesterToggle.checked = JSON.parse(localStorage.getItem("jesterEnabled")) || false;
jackalToggle.checked = JSON.parse(localStorage.getItem("jackalEnabled")) || false;
viperToggle.checked = JSON.parse(localStorage.getItem("viperEnabled")) || false;
shieldToggle.checked = JSON.parse(localStorage.getItem("shieldEnabled")) || false;
assassinToggle.checked = JSON.parse(localStorage.getItem("assassinEnabled")) || false;
kingToggle.checked = JSON.parse(localStorage.getItem("kingEnabled")) || false;
loversToggle.checked = JSON.parse(localStorage.getItem("loversEnabled")) || false;
cluelessToggle.checked = JSON.parse(localStorage.getItem("cluelessEnabled")) || false;
echoToggle.checked = JSON.parse(localStorage.getItem("echoEnabled")) || false;
idiotToggle.checked = JSON.parse(localStorage.getItem("idiotEnabled")) || false;
philosopherToggle.checked = JSON.parse(localStorage.getItem("philosopherEnabled")) || false;
sheriffToggle.checked = JSON.parse(localStorage.getItem("sheriffEnabled")) || false;
maniacToggle.checked = JSON.parse(localStorage.getItem("maniacEnabled")) || false;
cultistToggle.checked = JSON.parse(localStorage.getItem("cultistEnabled")) || false;
shadowToggle.checked = JSON.parse(localStorage.getItem("shadowEnabled")) || false;

// We do NOT save randomize state to local storage to force a fresh decision, or we can save it.
// For now, let's default it to false to be safe, or user preference.
randomizeToggle.checked = false;

// Load player names from localStorage if they exist, otherwise use default
const savedPlayerNames = JSON.parse(localStorage.getItem("playerNames"));
if (savedPlayerNames && Array.isArray(savedPlayerNames) && savedPlayerNames.length > 0) {
  playerNames = [...savedPlayerNames]; // Use saved names
} else {
  playerNames = []; // Start with empty array
}

// Load Custom Subjects
const savedSubjectsJSON = localStorage.getItem("savedCustomSubjects");
if (savedSubjectsJSON) {
  try {
    savedCustomSubjects = JSON.parse(savedSubjectsJSON);
  } catch (e) {
    savedCustomSubjects = {};
  }
}

/* ===== MODAL FUNCTIONS ===== */
function openModal() {
  modalOverlay.classList.add('active');
  document.body.style.overflow = 'hidden';
}

function closeModal() {
  modalOverlay.classList.remove('active');
  document.body.style.overflow = 'auto';
}

// Modal event listeners
infoBtn.addEventListener('click', openModal);
closeModalBtn.addEventListener('click', closeModal);

// Close modal when clicking outside
modalOverlay.addEventListener('click', (e) => {
  if (e.target === modalOverlay) {
    closeModal();
  }
});

// Close modal with Escape key
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && modalOverlay.classList.contains('active')) {
    closeModal();
  }
});

/* ===== CREATE SUBJECT MODAL FUNCTIONS ===== */
function openCreateSubjectModal() {
  newSubjectNameInput.value = "";
  // clear dynamic categories container
  categoriesContainer.innerHTML = "";
  // Add first category block by default
  addCategoryBlock();
  
  createSubjectOverlay.classList.add('active');
}

function closeCreateSubjectModal() {
  createSubjectOverlay.classList.remove('active');
}

function addCategoryBlock() {
  const div = document.createElement("div");
  div.className = "category-block";
  
  // Create Remove Button
  const removeBtn = document.createElement("button");
  removeBtn.className = "remove-category-btn";
  removeBtn.innerHTML = "&times;";
  removeBtn.title = "Remove Category";
  removeBtn.onclick = function() {
    // Only allow removal if more than 1 category remains
    if (categoriesContainer.children.length > 1) {
      div.remove();
    } else {
      alert("Subject must have at least one category.");
    }
  };
  
  // HTML Structure for Category Name + Words
  div.innerHTML = `
    <div class="form-group" style="margin-bottom: 12px;">
      <label class="form-label">Category Name</label>
      <input type="text" class="form-input cat-name-input" placeholder="e.g. Troops, Spells...">
    </div>
    <div class="form-group" style="margin-bottom: 0;">
      <label class="form-label">Words List</label>
      <textarea class="form-textarea words-textarea" placeholder="Enter words separated by commas or new lines."></textarea>
      <div class="form-hint">At least 2 words required.</div>
    </div>
  `;
  
  div.appendChild(removeBtn);
  categoriesContainer.appendChild(div);
}

function saveNewSubject() {
  const name = newSubjectNameInput.value.trim();
  
  if (!name) {
    alert("Please enter a subject name.");
    return;
  }
  
  const subjectData = {};
  const categoryBlocks = categoriesContainer.querySelectorAll(".category-block");
  let hasValidData = false;
  
  // Loop through each category block to build the data
  for (let block of categoryBlocks) {
    const catName = block.querySelector(".cat-name-input").value.trim();
    const wordsRaw = block.querySelector(".words-textarea").value;
    
    // Validation
    if (!catName) {
      alert("All categories must have a name.");
      return;
    }
    
    // Words parsing
    const words = wordsRaw.split(/[\n,]+/).map(w => w.trim()).filter(w => w.length > 0);
    
    if (words.length < 2) {
      alert(`Category "${catName}" must have at least 2 words.`);
      return;
    }
    
    subjectData[catName] = words;
    hasValidData = true;
  }
  
  if (!hasValidData) return;
  
  if (defaultSubjects[name] || savedCustomSubjects[name]) {
    if (!confirm(`Subject "${name}" already exists. Overwrite?`)) {
      return;
    }
  }
  
  // Save structure: { "SubjectName": { "Cat1": [words], "Cat2": [words] } }
  savedCustomSubjects[name] = subjectData;
  
  localStorage.setItem("savedCustomSubjects", JSON.stringify(savedCustomSubjects));
  
  closeCreateSubjectModal();
  initializeSubjectOptions(); // Re-render list
  
  // Select the new subject automatically
  selectSubject(name);
}

function submitToGithub() {
  const name = newSubjectNameInput.value.trim();
  
  if (!name) {
    alert("Please enter a subject name.");
    return;
  }
  
  // Reuse logic to build the subject data
  const subjectData = {};
  const categoryBlocks = categoriesContainer.querySelectorAll(".category-block");
  let hasValidData = false;
  
  for (let block of categoryBlocks) {
    const catName = block.querySelector(".cat-name-input").value.trim();
    const wordsRaw = block.querySelector(".words-textarea").value;
    
    if (!catName || wordsRaw.trim().length === 0) {
      alert("Please complete all category fields.");
      return;
    }
    
    const words = wordsRaw.split(/[\n,]+/).map(w => w.trim()).filter(w => w.length > 0);
    if (words.length < 2) {
      alert(`Category "${catName}" must have at least 2 words.`);
      return;
    }
    subjectData[catName] = words;
    hasValidData = true;
  }
  
  if (!hasValidData) return;

  // Format the JSON object for the body
  // We want it to look like: "Subject Name": { "Category": ["A", "B"] },
  const fullObject = {};
  fullObject[name] = subjectData;
  
  // Pretty print JSON, remove outer braces for easy copy-pasting into existing object
  let jsonString = JSON.stringify(fullObject, null, 2);
  // Remove first and last curly braces to make it a property list
  jsonString = jsonString.substring(1, jsonString.length - 1).trim();
  // Add a trailing comma
  jsonString += ",";

  const issueTitle = `New Subject Proposal: ${name}`;
  const issueBody = `Here is a new subject for the Imposter Game!\n\n\`\`\`javascript\n${jsonString}\n\`\`\`\n\n(leon is so cool)`;

  // GitHub Issue URL
  const url = `https://github.com/leoniscooler/imposter/issues/new?title=${encodeURIComponent(issueTitle)}&body=${encodeURIComponent(issueBody)}`;
  
  window.open(url, '_blank');
}

function deleteCustomSubject(e, subjectName) {
  e.stopPropagation(); // Prevent selecting the subject when clicking delete
  if (confirm(`Are you sure you want to delete "${subjectName}"?`)) {
    delete savedCustomSubjects[subjectName];
    localStorage.setItem("savedCustomSubjects", JSON.stringify(savedCustomSubjects));
    
    // If the deleted subject was selected, clear selection
    if (currentSubject === subjectName) {
      changeSubject();
    }
    
    initializeSubjectOptions();
  }
}

// Create Modal Listeners
closeCreateSubjectBtn.addEventListener('click', closeCreateSubjectModal);
cancelCreateSubjectBtn.addEventListener('click', closeCreateSubjectModal);
saveSubjectBtn.addEventListener('click', saveNewSubject);
submitGithubBtn.addEventListener('click', submitToGithub);
addCategoryBtn.addEventListener('click', addCategoryBlock);

createSubjectOverlay.addEventListener('click', (e) => {
  if (e.target === createSubjectOverlay) closeCreateSubjectModal();
});


/* ===== UPDATE SLIDER DISPLAY ===== */
function updateSliderDisplays() {
  playersValue.textContent = playerSlider.value;
  impostersValue.textContent = imposterSlider.value;
}

// Initialize slider displays
updateSliderDisplays();

// Update slider displays when sliders change
playerSlider.addEventListener('input', updateSliderDisplays);
imposterSlider.addEventListener('input', updateSliderDisplays);

// Also update when sliders change via touch/mouse move
playerSlider.addEventListener('change', updateSliderDisplays);
imposterSlider.addEventListener('change', updateSliderDisplays);

/* ===== INITIALIZE SUBJECT OPTIONS ===== */
function initializeSubjectOptions() {
  subjectOptions.innerHTML = "";
  
  // 1. Add "Create New" Button (Manual)
  const createBtn = document.createElement("div");
  createBtn.className = "subject-option add-new";
  createBtn.innerHTML = "<span>+</span> Create Manual";
  createBtn.addEventListener("click", openCreateSubjectModal);
  subjectOptions.appendChild(createBtn);

  // 2. Add "AI Generate" Button (New!)
  const aiBtn = document.createElement("div");
  aiBtn.className = "subject-option ai-generate";
  aiBtn.innerHTML = "<span>‚ú®</span> AI Generate";
  aiBtn.addEventListener("click", openAiModal);
  subjectOptions.appendChild(aiBtn);
  
  // 3. Combine and Sort all subjects (Default + Saved)
  const allKeys = [
    ...Object.keys(defaultSubjects),
    ...Object.keys(savedCustomSubjects)
  ].sort();
  
  const uniqueKeys = [...new Set(allKeys)];
  
  uniqueKeys.forEach(subject => {
    const isCustom = savedCustomSubjects.hasOwnProperty(subject);
    
    const option = document.createElement("div");
    option.className = "subject-option";
    option.textContent = subject;
    option.dataset.subject = subject;
    
    if (subject === currentSubject) {
      option.classList.add("selected");
    }
    
    option.addEventListener("click", () => selectSubject(subject));
    
    if (isCustom) {
      const deleteBtn = document.createElement("div");
      deleteBtn.className = "delete-subject-btn";
      deleteBtn.innerHTML = "&times;";
      deleteBtn.title = "Delete Subject";
      deleteBtn.addEventListener("click", (e) => deleteCustomSubject(e, subject));
      option.appendChild(deleteBtn);
    }
    
    subjectOptions.appendChild(option);
  });
}

/* ===== SUBJECT MANAGEMENT ===== */
function selectSubject(subject) {
  // Remove selected class from all options
  document.querySelectorAll('.subject-option').forEach(opt => {
    opt.classList.remove('selected');
  });
  
  // Add selected class to clicked option
  const selectedOption = document.querySelector(`[data-subject="${subject}"]`);
  if (selectedOption) {
    selectedOption.classList.add('selected');
  }
  
  currentSubject = subject;
  actualCustomSubject = ""; // Clear single-use custom subject
  
  // Determine source (Default or Custom)
  const sourceObject = defaultSubjects[subject] ? defaultSubjects : savedCustomSubjects;
  
  // Combine all items
  customItems = [];
  Object.values(sourceObject[subject]).forEach(categoryItems => {
    customItems.push(...categoryItems);
  });
  
  localStorage.setItem("currentSubject", currentSubject);
  localStorage.setItem("actualCustomSubject", actualCustomSubject);
  localStorage.setItem("customItems", JSON.stringify(customItems));
  
  showSelectedSubject();
  enableGenerateButton();
  errorBox.textContent = "";
  
  // Clear input
  customSubjectInput.value = "";
}

function useCustomSubject() {
  const subject = customSubjectInput.value.trim();
  if (!subject) {
    errorBox.textContent = "Please enter a custom subject";
    return;
  }
  
  // Remove selected class from all options
  document.querySelectorAll('.subject-option').forEach(opt => {
    opt.classList.remove('selected');
  });
  
  // Store the actual custom word privately
  actualCustomSubject = subject;
  // Display "Custom" to users so they can't see what was entered
  currentSubject = "Custom";
  
  // Use only the exact word/phrase entered - no modifications
  customItems = [actualCustomSubject];
  
  localStorage.setItem("currentSubject", currentSubject);
  localStorage.setItem("actualCustomSubject", actualCustomSubject);
  localStorage.setItem("customItems", JSON.stringify(customItems));
  
  showSelectedSubject();
  enableGenerateButton();
  errorBox.textContent = "";
  
  // Clear input
  customSubjectInput.value = "";
}

function showSelectedSubject() {
  selectedSubjectName.textContent = currentSubject;
  subjectDisplay.style.display = 'block';
  subjectSelection.style.display = 'none';
}

function changeSubject() {
  subjectDisplay.style.display = 'none';
  subjectSelection.style.display = 'block';
  generateBtn.disabled = true;
  generateBtn.textContent = "Select Subject First";
  
  // Clear any existing cards
  cardsContainer.innerHTML = "";
  revealTracker.textContent = "";
  firstPlayerBox.classList.remove('show');
  firstPlayerBox.textContent = '';
  revealRolesBtn.style.display = 'none';
  rolesRevealBox.classList.remove('show');
  rolesRevealBox.innerHTML = '';
  kingAnnouncement.classList.remove('show');
  kingAnnouncement.textContent = '';
}

function enableGenerateButton() {
  generateBtn.disabled = false;
  generateBtn.textContent = "Deal Cards";
}

/* ===== PLAYER NAMES MANAGEMENT ===== */
function updatePlayerNamesList() {
  const playerCount = parseInt(playerSlider.value, 10);
  playerNamesList.innerHTML = "";
  
  // Ensure playerNames array has the right length
  // Keep existing names for existing players, add default names for new players
  for (let i = 0; i < playerCount; i++) {
    if (i >= playerNames.length) {
      playerNames.push(`Player ${i + 1}`);
    }
  }
  
  // Trim if player count decreased (only remove from end)
  playerNames = playerNames.slice(0, playerCount);
  
  // Save to localStorage
  localStorage.setItem("playerNames", JSON.stringify(playerNames));
  
  // Update player count display
  playerCountDisplay.textContent = playerCount;
  
  // Create input for each player
  for (let i = 0; i < playerCount; i++) {
    const container = document.createElement("div");
    container.className = "player-name-input-container";
    
    const label = document.createElement("div");
    label.className = "player-name-label";
    label.textContent = `Player ${i + 1}`;
    
    const input = document.createElement("input");
    input.className = "player-name-input";
    input.type = "text";
    input.value = playerNames[i] || `Player ${i + 1}`;
    input.placeholder = `Player ${i + 1}`;
    input.dataset.index = i;
    
    // Update player name when input changes
    input.addEventListener("input", (e) => {
      const index = parseInt(e.target.dataset.index);
      playerNames[index] = e.target.value.trim() || `Player ${index + 1}`;
      localStorage.setItem("playerNames", JSON.stringify(playerNames));
    });
    
    container.appendChild(label);
    container.appendChild(input);
    playerNamesList.appendChild(container);
  }
}

function resetPlayerNames() {
  const playerCount = parseInt(playerSlider.value, 10);
  
  // Reset to Player 1, Player 2, etc.
  playerNames = [];
  for (let i = 0; i < playerCount; i++) {
    playerNames.push(`Player ${i + 1}`);
  }
  
  // Save to localStorage and update UI
  localStorage.setItem("playerNames", JSON.stringify(playerNames));
  updatePlayerNamesList();
}

function addPlayer() {
  let playerCount = parseInt(playerSlider.value, 10);
  if (playerCount < 20) {
    playerCount++;
    playerSlider.value = playerCount;
    updateSliderDisplays();
    
    // Add new player name
    playerNames.push(`Player ${playerCount}`);
    localStorage.setItem("playerNames", JSON.stringify(playerNames));
    
    // Update the player names list if it's visible
    if (playerNamesSection.style.display === 'block') {
      updatePlayerNamesList();
    }
    
    // Save to localStorage
    localStorage.setItem("playerCount", playerCount);
  }
}

function removePlayer() {
  let playerCount = parseInt(playerSlider.value, 10);
  if (playerCount > 3) {
    playerCount--;
    playerSlider.value = playerCount;
    updateSliderDisplays();
    
    // Remove last player name
    playerNames.pop();
    localStorage.setItem("playerNames", JSON.stringify(playerNames));
    
    // Update the player names list if it's visible
    if (playerNamesSection.style.display === 'block') {
      updatePlayerNamesList();
    }
    
    // Save to localStorage
    localStorage.setItem("playerCount", playerCount);
  }
}

function showPlayerNames() {
  playerNamesSection.style.display = 'block';
  showPlayerNamesBtn.style.display = 'none';
  updatePlayerNamesList();
}

function hidePlayerNames() {
  playerNamesSection.style.display = 'none';
  showPlayerNamesBtn.style.display = 'block';
}

/* ===== UPDATE TRACKER ===== */
function updateTracker() {
  if (totalCards === 0) {
    revealTracker.textContent = "";
    return;
  }
  
  revealTracker.textContent = `Revealed: ${revealedCards} / ${totalCards} cards`;

  // ‚úÖ When everyone has seen their role
  if (lockedCards === totalCards) {
    document.getElementById("startVotingBtn").style.display = "block";
  }
}
  
  revealTracker.textContent = `Revealed: ${revealedCards} / ${totalCards} cards`;

/* ===== ANNOUNCE KING PLAYER ===== */
function announceKingPlayer() {
  // Check the global flags (set during generation) instead of current toggle state
  // because randomizer might have enabled it internally for this round
  const isKingActive = words.some((_, i) => i === kingPlayer);
  
  if (kingPlayer !== null) {
    const playerName = playerNames[kingPlayer] || `Player ${kingPlayer + 1}`;
    
    setTimeout(() => {
      kingAnnouncement.textContent = `${playerName} is the King!\nThey get 2 votes!`;
      kingAnnouncement.classList.add('show');
      kingAnnouncement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 500);
  }
}
// SELECT FIRST PLAYER //
function selectFirstPlayer() {
  const randomPlayer = Math.floor(Math.random() * totalCards) + 1;

  setTimeout(() => {
    const playerName = playerNames[randomPlayer - 1] || `Player ${randomPlayer}`;
    firstPlayerBox.textContent = `${playerName} goes first!`;
    firstPlayerBox.classList.add('show');

    // üëá SHOW START VOTING BUTTON HERE
    startVotingBtn.style.display = "block";
startVotingBtn.classList.add("show");
console.log("Button shown");
setTimeout(() => {
  console.log("After 300ms:", window.getComputedStyle(startVotingBtn).opacity);
  console.log("Parent opacity:", window.getComputedStyle(startVotingBtn.parentElement).opacity);
}, 300);

  }, 500);
}

/* ===== REVEAL ALL ROLES ===== */
function revealAllRoles() {
  const roleList = document.createElement('div');
  roleList.className = 'roles-reveal-content';
  
  const header = document.createElement('div');
  header.className = 'roles-reveal-header';
  header.innerHTML = '<h3>All Roles Revealed</h3>';
  
  const listContainer = document.createElement('ul');
  listContainer.className = 'role-list';
  
  words.forEach((word, i) => {
    const playerNumber = i + 1;
    const playerName = playerNames[i] || `Player ${playerNumber}`;
    
    let roleName = "";
    let roleClass = "";
    let specialNote = "";
    let isKing = (i === kingPlayer);
    let isLovers = loverIndexes.includes(i);
    
    if (word === secretItem) {
      roleName = "Civilian";
      roleClass = "civilian-role";
    } else if (word === "Imposter") {
      roleName = "Imposter";
      roleClass = "imposter-role";
    } else if (word === "Dictator") {
      roleName = "Dictator";
      roleClass = "dictator-role";
    } else if (word === "Mastermind") {
      roleName = "Mastermind";
      roleClass = "mastermind-role";
    } else if (word === "Hunter") {
      roleName = "Hunter";
      roleClass = "hunter-role";
    } else if (word === "Detective") {
      roleName = "Detective";
      roleClass = "detective-role";
    } else if (word === "Jester") {
      roleName = "Jester";
      roleClass = "jester-role";
    } else if (word === "Jackal") {
      roleName = "Jackal";
      roleClass = "jackal-role";
    } else if (word === "Viper") {
      roleName = "Viper";
      roleClass = "viper-role";
    } else if (word === "Shield") {
      roleName = "Shield";
      roleClass = "shield-role";
    } else if (word === "Clueless") {
      roleName = "Clueless";
      roleClass = "clueless-role";
      // Show what word they had
      specialNote = `<div class="clueless-word-display">Thought the word was: "${cluelessWord}"</div>`;
    }  else if (word === "Echo") {
      roleName = "Echo";
      roleClass = "echo-role";
    }  else if (word === "Idiot") {
      roleName = "Idiot";
      roleClass = "idiot-role";
    }  else if (word === "Philosopher") {
      roleName = "Philosopher";
      roleClass = "philosopher-role";
    }  else if (word === "Sheriff") {
      roleName = "Sheriff";
      roleClass = "sheriff-role";
    }  else if (word === "Maniac") {
      roleName = "Maniac";
      roleClass = "maniac-role";
    }  else if (word === "Cultist") {
      roleName = "Cultist";
      roleClass = "cultist-role";
    }  else if (word === "Shadow") {
      roleName = "Shadow";
      roleClass = "shadow-role";
    } else if (word === "Assassin") {
      roleName = "Assassin";
      roleClass = "assassin-role";
      if (assassinTarget) {
        const targetName = playerNames[assassinTarget - 1] || `Player ${assassinTarget}`;
        specialNote = `<div class="assassin-target">Target: ${targetName}</div>`;
      }
    }
    
    if (isKing) {
      if (roleClass) {
        roleClass += " king-role";
      } else {
        roleClass = "king-role";
      }
    }    
    
    if (isLovers) {
      if (roleClass) {
        roleClass += " lovers-role";
      } else {
        roleClass = "lovers-role";
      }
    }
    
const li = document.createElement('li');

li.innerHTML = `
  <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
    <span class="player-number">${playerName}</span>
    <div style="flex: 1; display: flex; flex-direction: column; align-items: flex-end;">
      <span class="role-name ${roleClass}">
        ${roleName}${isKing ? ' (King)' : ''}${isLovers ? ' (Lovers)' : ''}
      </span>

      ${isKing ? '<div class="king-badge">Has 2 votes!</div>' : ''}
      ${isLovers ? '<div class="lovers-badge">Has a lover!</div>' : ''}
    </div>
  </div>
`;

listContainer.appendChild(li);
  });
  
  roleList.appendChild(header);
  roleList.appendChild(listContainer);
  
  rolesRevealBox.innerHTML = '';
  rolesRevealBox.appendChild(roleList);
  rolesRevealBox.classList.add('show');
  revealRolesBtn.style.display = 'none';
  rolesRevealBox.scrollIntoView({ behavior: 'smooth', block: 'center' });
}
/* ===== VOTING FEATURE ===== */
const startVotingBtn = document.getElementById("startVotingBtn");
const votingBox = document.getElementById("votingBox");

startVotingBtn.addEventListener("click", () => {
  votingBox.style.display = "block";
  startVotingBtn.style.display = "none";

  startVotingPhase();   // ‚úÖ just call it
});

function startVotingPhase() {

  // Fade out button
  startVotingBtn.classList.add("fade-out");

  // After animation finishes, hide it completely
  setTimeout(() => {
    startVotingBtn.style.display = "none";
  }, 400); // match animation duration

  currentVoterIndex = 0;
  votes = {};

  showNextVoter();
}

function showNextVoter() {

  // Skip dead players
  while (currentVoterIndex < players.length && !players[currentVoterIndex].alive) {
    currentVoterIndex++;
  }

  if (currentVoterIndex >= players.length) {
    finishVoting();
    return;
  }

  const voter = players[currentVoterIndex];

  votingBox.innerHTML = `
    <div class="roles-reveal-header">
      <h3>${voter.name}, it's your turn to vote</h3>
    </div>
    <div class="roles-reveal-content" id="voteOptions"></div>
  `;

  votingBox.classList.add("show");

  votingBox.classList.remove("vote-fade-in"); // reset if already present
void votingBox.offsetWidth; // force reflow (important!)
votingBox.classList.add("vote-fade-in");

  const voteOptions = document.getElementById("voteOptions");

  players.forEach((player, index) => {
    if (player.alive) {
      const btn = document.createElement("button");
      btn.textContent = player.name;
      btn.className = "reveal-roles-btn";
      btn.style.marginBottom = "8px";

      btn.onclick = () => castVote(index);

      voteOptions.appendChild(btn);
    }
  });
}

function showViperCooldownScreen() {

  votingBox.innerHTML = `
    <div class="roles-reveal-header">
      <h3>üêç Poison Refueling...</h3>
    </div>
    <div class="roles-reveal-content">
      <p>
        Another dose is being made.
      </p>
      <p style="font-style:italic; margin-top:10px;">
        You may poison again next meeting.
      </p>
    </div>
  `;

  clearContinueButtons(); // safety

  const continueBtn = document.createElement("button");
  continueBtn.textContent = "Continue";
  continueBtn.className = "reveal-roles-btn";
  continueBtn.style.marginTop = "15px";

  continueBtn.onclick = () => {
    currentVoterIndex++;
    showNextVoter();
  };

  votingBox.appendChild(continueBtn);
}

function castVote(targetIndex) {

  const voter = players[currentVoterIndex];
  if (!voter || !voter.alive) return;

  players[currentVoterIndex].vote = targetIndex;

  let voteWeight = 1;

  if (currentVoterIndex === kingPlayer) voteWeight = 2;
  if (voter.role === "Maniac") voteWeight = 0;
  if (voter.role === "Viper") voteWeight = 0;

  if (!votes[targetIndex]) {
    votes[targetIndex] = 0;
  }

  votes[targetIndex] += voteWeight;

  // üêç VIPER
  if (voter.role === "Viper" && !viperChoosingPoison) {

  // üêç If refueling, show cooldown screen instead
  if (viperCooldown) {
    showViperCooldownScreen();
    return;
  }

  viperChoosingPoison = true;
  showPoisonScreen();
  return;
}

  // ‚≠ê SHERIFF
  if (voter.role === "Sheriff" && sheriffShotTarget === null) {
    showSheriffShootOptions(targetIndex);
    return;
  }

  // üëë DICTATOR
  if (voter.role === "Dictator") {
    showDictatorBlockScreen();
    return;
  }

  // üèπ HUNTER
if (voter.role === "Hunter") {
  showHunterDecisionScreen();
  return;
}

  // ‚úÖ Normal advance
  currentVoterIndex++;
  setTimeout(() => {
    showNextVoter();
  }, 150);
}

  function showDictatorBlockScreen() {

  const dictator = players[currentVoterIndex];

  // üîÑ Build live vote map BEFORE cancellation
  let liveVotes = {};

  players.forEach((player, index) => {
    if (!player.alive) return;
    if (player.vote === null) return;

    let weight = 1;
    if (index === kingPlayer) weight = 2;
    if (player.role === "Maniac") weight = 0;
    if (player.role === "Viper") weight = 0;

    if (!liveVotes[player.vote]) liveVotes[player.vote] = 0;
    liveVotes[player.vote] += weight;
  });

  // üó≥ Build vote breakdown
  let voteBreakdownHTML = `
    <div class="dictator-intel">
      <hr>
      <h3>üó≥ Current Votes</h3>
  `;

  players.forEach((player, index) => {
    if (!player.alive) return;

    const voteCount = liveVotes[index] || 0;

    voteBreakdownHTML += `
      <p><strong>${player.name}</strong>: ${voteCount} vote${voteCount !== 1 ? "s" : ""}</p>
    `;
  });

  voteBreakdownHTML += `<hr><h3>üïµÔ∏è Who Voted For Who</h3>`;

  players.forEach((player, index) => {
    if (!player.alive) return;
    if (player.vote === null) return;

    const votedFor = players[player.vote]?.name || "Nobody";

    voteBreakdownHTML += `
      <p>${player.name} ‚ûú ${votedFor}</p>
    `;
  });

  voteBreakdownHTML += `</div>`;

  // üé≠ Render Screen
  votingBox.innerHTML = `
    <div class="dictator-screen">
      <h2 style="color:white">
        üëë ${dictator.name}, you control the narrative.
      </h2>
      <p>Silence one voice‚Ä¶ or let chaos unfold.</p>
    </div>

    ${voteBreakdownHTML}

    <div class="roles-reveal-content" id="dictatorOptions"></div>
  `;

  const optionsBox = document.getElementById("dictatorOptions");

  // üéØ Target selection (no self)
  players.forEach((player, index) => {
    if (!player.alive || index === currentVoterIndex) return;

    const btn = document.createElement("button");
    btn.className = "reveal-roles-btn";
    btn.textContent = `Cancel ${player.name}'s vote`;

    btn.onclick = () => {
      dictatorBlockedPlayer = index;

      votingBox.innerHTML = `
        <div class="roles-reveal-header">
          <h3 style="color:${roleColors["Dictator"]}">
            üëë Decree Issued
          </h3>
        </div>
        <div class="roles-reveal-content">
          <p>${player.name}'s vote will not be counted.</p>
        </div>
      `;

clearContinueButtons();

      const continueBtn = document.createElement("button");
      continueBtn.textContent = "Continue";
      continueBtn.className = "reveal-roles-btn";
      continueBtn.onclick = proceedToNextVoter;

      votingBox.appendChild(continueBtn);
    };

    optionsBox.appendChild(btn);
  });

  // üü¢ Skip Option
  const skipBtn = document.createElement("button");
  skipBtn.textContent = "Skip (Let all votes stand)";
  skipBtn.className = "reveal-roles-btn";
  skipBtn.style.marginTop = "10px";
  skipBtn.style.opacity = "0.8";

  skipBtn.onclick = () => {
    dictatorBlockedPlayer = null;
    proceedToNextVoter();
  };

  optionsBox.appendChild(skipBtn);
  }


function proceedToNextVoter() {
  currentVoterIndex++;
  setTimeout(() => {
    showNextVoter();
  }, 150);
}

function showPoisonScreen() {

  const viper = players[currentVoterIndex];

  votingBox.innerHTML = `
    <div class="roles-reveal-header">
      <h3>üêç ${viper.name}, choose who to <span class="poison-text">POISON</span></h3>
    </div>
    <div class="roles-reveal-content" id="poisonOptions"></div>
  `;

  const poisonOptions = document.getElementById("poisonOptions");

  players.forEach((player, index) => {

    if (player.alive && index !== currentVoterIndex) {

      const btn = document.createElement("button");
      btn.textContent = player.name;
      btn.className = "reveal-roles-btn poison-btn";

     btn.onclick = () => {

  viperNextPoison = index;
  viperCooldown = true; // start cooldown

  currentVoterIndex++;
  setTimeout(() => {
    showNextVoter();
  }, 150);
};

      poisonOptions.appendChild(btn);
    }
  });
}

function handleLoverChainDeath(deadIndex) {

  const deadPlayer = players[deadIndex];

  if (!deadPlayer.isLover) return null;

  const otherLoverIndex = players.findIndex(
    (p, i) => p.isLover && i !== deadIndex && p.alive
  );

  if (otherLoverIndex !== -1) {
    players[otherLoverIndex].alive = false;
    if (
  hunterMarkedTarget !== null &&
  !players[hunterMarkedTarget]?.alive
) {
  hunterMarkedTarget = null;
}
    return otherLoverIndex; // üî• return who died
  }

  return null;
}

function resolveSheriffNow() {

  if (sheriffShotTarget === null) {
    addContinueButton();
    return;
  }

  const sheriff = players.find(p => p.role === "Sheriff");

  if (!sheriff || !sheriff.alive) {
    sheriffShotTarget = null;
    addContinueButton();
    return;
  }

  const target = players[sheriffShotTarget];

  if (!target || !target.alive) {
    sheriffShotTarget = null;
    addContinueButton();
    return;
  }

  // üé≠ Jester shot
  if (target.role === "Jester") {
    endGame(
      `<strong>${target.name} the Jester wins!</strong><br>
       They were shot by the Sheriff!`,
      "Jester"
    );
    return;
  }

  let loverDeathIndex = null;

  if (sheriffAllowedRoles.includes(target.role)) {

    target.alive = false;
    if (
  hunterMarkedTarget !== null &&
  !players[hunterMarkedTarget]?.alive
) {
  hunterMarkedTarget = null;
}
    loverDeathIndex = handleLoverChainDeath(sheriffShotTarget);

    votingBox.innerHTML += `
      <hr>
      <h3>üî´ ${target.name} was shot by the Sheriff!</h3>
      <p>
        They were the 
        <span style="color:${roleColors[target.role]}; font-weight:bold;">
          ${target.role}
        </span>
      </p>
    `;

  } else {

    sheriff.alive = false;
    if (
  hunterMarkedTarget !== null &&
  !players[hunterMarkedTarget]?.alive
) {
  hunterMarkedTarget = null;
}
    const sheriffIndex = players.findIndex(p => p.role === "Sheriff");
    const sheriff = players.find(p => p.role === "Sheriff");

if (!sheriff || !sheriff.alive) {
  sheriffShotTarget = null;
  addContinueButton();
  return;
}
    loverDeathIndex = handleLoverChainDeath(sheriffIndex);

    votingBox.innerHTML += `
      <hr>
      <h3>‚ùå The Sheriff shot the wrong person and died!</h3>
    `;
  }

  if (loverDeathIndex !== null) {
    const lover = players[loverDeathIndex];
    votingBox.innerHTML += `
      <div class="lover-death-message">
        <hr>
        <h3>üíî ${lover.name} could not live without their lover...</h3>
        <p>
          They were the 
          <span style="color:${roleColors[lover.role]}; font-weight:bold;">
            ${lover.role}
          </span>
        </p>
      </div>
    `;
  }

  sheriffShotTarget = null;

  addContinueButton();
}

function showHunterDecisionScreen() {

  const hunterIndex = currentVoterIndex;

  // üî• FORCE target selection if none exists
 if (hunterMarkedTarget === null) {

  votingBox.innerHTML = `
    <div class="roles-reveal-header">
      <h3>üèπ Choose Your Prey</h3>
    </div>
    <div class="roles-reveal-content" id="hunterTargetOptions"></div>
  `;

  const optionsBox = document.getElementById("hunterTargetOptions");

  players.forEach((player, index) => {

    if (!player.alive || index === currentVoterIndex) return;

    const btn = document.createElement("button");
    btn.className = "reveal-roles-btn";
    btn.textContent = player.name;

    btn.onclick = () => {

      hunterMarkedTarget = index;

      // üî• IMPORTANT:
      // After picking target, continue voting immediately.
      currentVoterIndex++;
      setTimeout(() => {
        showNextVoter();
      }, 150);
    };

    optionsBox.appendChild(btn);
  });

  return;
}

  const targetIndex = hunterMarkedTarget;

  votingBox.innerHTML = `
    <div class="roles-reveal-header">
      <h3>üèπ Hunter Decision</h3>
    </div>
    <div class="roles-reveal-content">
      <p>Your current prey: <strong>${players[targetIndex].name}</strong></p>
      <button id="hunterKill" class="reveal-roles-btn">Kill</button>
      <button id="hunterSpare" class="reveal-roles-btn">Spare</button>
      <button id="hunterChange" class="reveal-roles-btn">Change Target</button>
    </div>
  `;

  document.getElementById("hunterKill").onclick = () => {
    hunterPendingKill = targetIndex;

    currentVoterIndex++;
    setTimeout(() => {
      showNextVoter();
    }, 150);
  };

  document.getElementById("hunterSpare").onclick = () => {

    currentVoterIndex++;
    setTimeout(() => {
      showNextVoter();
    }, 150);
  };

  document.getElementById("hunterChange").onclick = () => {

    hunterMarkedTarget = null;

    showHunterDecisionScreen(); // re-force selection
  };
}

function enableHunterRetargetMode() {

  players.forEach((player, index) => {

    if (!player.alive) return;

    const btn = document.createElement("button");
    btn.textContent = player.name;
    btn.className = "reveal-roles-btn";

    btn.onclick = () => {

      hunterMarkedTarget = index;
      hunterCanRetarget = false;

      votingBox.innerHTML = `
        <h3>üéØ New target locked: ${player.name}</h3>
      `;

clearContinueButtons();

      const continueBtn = document.createElement("button");
      continueBtn.textContent = "Continue";
      continueBtn.className = "reveal-roles-btn";
      continueBtn.onclick = () => {
        currentVoterIndex++;
        showNextVoter();
      };

      votingBox.appendChild(continueBtn);
    };

    votingBox.appendChild(btn);
  });
}

function clearContinueButtons() {
  const buttons = votingBox.querySelectorAll(".reveal-roles-btn");
  buttons.forEach(btn => {
    if (btn.textContent === "Continue") {
      btn.remove();
    }
  });
}

function showSheriffShootOptions(voteTargetIndex) {

  const sheriff = players[currentVoterIndex];

  votingBox.innerHTML = `
  <div class="sheriff-header">
    <h2>Sheriff Action</h2>
    <p>This decision is yours alone.</p>
  </div>

  <div class="sheriff-content" id="sheriffOptions"></div>

  <div class="sheriff-footer">
    <p class="sheriff-warning">
      Shoot wisely‚Ä¶ a mistake will cost your life.
    </p>
  </div>
`;

  const container = document.getElementById("sheriffOptions");

  players.forEach((player, index) => {

    if (player.alive && index !== currentVoterIndex) {

      const btn = document.createElement("button");
      btn.textContent = player.name;
      btn.className = "reveal-roles-btn sheriff-btn";
      btn.style.marginBottom = "8px";

      btn.onclick = () => {
        sheriffShotTarget = index;

        // Continue voting normally
        currentVoterIndex++;
        showNextVoter();
      };

      container.appendChild(btn);
    }
  });

  // Skip button
  const skipBtn = document.createElement("button");
skipBtn.textContent = "Holster Weapon (Skip)";
skipBtn.className = "reveal-roles-btn";
skipBtn.style.background = "#334155";
skipBtn.style.color = "white";
skipBtn.style.marginTop = "10px";
skipBtn.className = "reveal-roles-btn sheriff-btn sheriff-skip";

skipBtn.onclick = () => {
  sheriffShotTarget = null;
  showNextVoter();
};

  skipBtn.onclick = () => {
    currentVoterIndex++;
    showNextVoter();
  };

  container.appendChild(skipBtn);
}

function finishVoting() {

  meetingMessages = ""; // always reset at start

  // =====================================================
  // üß™ PHASE 1 ‚Äî PRE-MEETING EFFECTS (Poison)
  // =====================================================

// üêç Activate poison scheduled last round
if (viperAnnouncedPoison !== null) {
  viperActivePoison = viperAnnouncedPoison;
  viperAnnouncedPoison = null;
}

  // üêç Activate previously announced poison
if (
  viperActivePoison !== null &&
  players[viperActivePoison] &&
  players[viperActivePoison].alive
) {
  const poisoned = players[viperActivePoison];
  poisoned.alive = false;
  if (
  hunterMarkedTarget !== null &&
  !players[hunterMarkedTarget]?.alive
) {
  hunterMarkedTarget = null;
}

  const loverDeathIndex = handleLoverChainDeath(viperActivePoison);

  // üî• Second message (role reveal)
  meetingMessages += `
    <div class="poison-death">
      <h3>üêç ${poisoned.name}'s heart got torn through by poison'.</h3>
      <p>
        They were the 
        <span style="color:${roleColors[poisoned.role]}; font-weight:bold;">
          ${poisoned.role}
        </span>
      </p>
    </div>
  `;

  if (loverDeathIndex !== null) {
    const lover = players[loverDeathIndex];
    meetingMessages += `
      <div class="lover-death-message">
        <h3>üíî ${lover.name} collapsed from heartbreak...</h3>
      </div>
    `;
  }

  viperActivePoison = null;
viperCooldown = false;
}

  // =====================================================
  // üó≥ PHASE 2 ‚Äî COUNT VOTES
  // =====================================================

  votes = {};

  players.forEach((player, index) => {
    if (!player.alive) return;
    if (index === dictatorBlockedPlayer) return;
    if (player.vote === null) return;

    let weight = 1;
    if (index === kingPlayer) weight = 2;
    if (player.role === "Maniac" || player.role === "Viper") weight = 0;

    if (!votes[player.vote]) votes[player.vote] = 0;
    votes[player.vote] += weight;
  });

  let maxVotes = Math.max(...Object.values(votes || {0:0}));
  let topPlayers = Object.keys(votes).filter(
    p => votes[p] === maxVotes
  );

  let eliminatedIndex = null;

  if (topPlayers.length === 1) {
    eliminatedIndex = parseInt(topPlayers[0]);
  }

  // =====================================================
  // üèπ PHASE 3 ‚Äî APPLY HUNTER KILL BEFORE RESOLUTION
  // =====================================================

  let hunterKilledIndex = null;

  if (hunterPendingKill !== null) {
    const targetIndex = Array.isArray(hunterPendingKill)
      ? hunterPendingKill[0]
      : hunterPendingKill;

    const target = players[targetIndex];

    if (target && target.alive) {
      target.alive = false;
      if (
  hunterMarkedTarget !== null &&
  !players[hunterMarkedTarget]?.alive
) {
  hunterMarkedTarget = null;
}
      hunterKilledIndex = targetIndex;

      const loverDeathIndex = handleLoverChainDeath(targetIndex);

      meetingMessages += `
        <hr>
        <div class="roles-reveal-content">
          <h3>üíÄ ${target.name} was hunted down!</h3>
          <p style="font-style: italic;">
            A silent hunter struck during the meeting...
          </p>
        </div>
      `;

      if (loverDeathIndex !== null) {
        const lover = players[loverDeathIndex];
        meetingMessages += `
          <div class="lover-death-message">
            <h3>üíî ${lover.name} collapsed from heartbreak...</h3>
          </div>
        `;
      }
    }

    hunterPendingKill = null;
  }

  // üêç Schedule poison for next meeting
if (viperNextPoison !== null) {
  viperAnnouncedPoison = viperNextPoison;

  meetingMessages += `
    <hr>
    <div class="roles-reveal-content">
      <h3>üß™ ${players[viperNextPoison].name} throws up violently...</h3>
      <p>Their future doesn't look so bright.</p>
    </div>
  `;

  viperNextPoison = null;
  viperCooldown = true;
}

// =====================================================
// ‚≠ê PHASE 3B ‚Äî APPLY SHERIFF ACTION
// =====================================================

if (sheriffShotTarget !== null) {

  const sheriffIndex = players.findIndex(p => p.role === "Sheriff");
  const sheriff = players[sheriffIndex];
  const target = players[sheriffShotTarget];

  if (sheriff && sheriff.alive && target && target.alive) {

    const isEvil = sheriffAllowedRoles.includes(target.role);

    if (isEvil) {

      target.alive = false;
      const loverDeathIndex = handleLoverChainDeath(sheriffShotTarget);

      meetingMessages += `
        <hr>
        <div class="roles-reveal-content">
          <h3>‚≠ê ${target.name} was shot by the Sheriff!</h3>
          <p>
            They were the 
            <span style="color:${roleColors[target.role]}; font-weight:bold;">
              ${target.role}
            </span>
          </p>
        </div>
      `;

      if (loverDeathIndex !== null) {
        const lover = players[loverDeathIndex];
        meetingMessages += `
          <div class="lover-death-message">
            <h3>üíî ${lover.name} collapsed from heartbreak...</h3>
          </div>
        `;
      }

    } else {

      sheriff.alive = false;
      const loverDeathIndex = handleLoverChainDeath(sheriffIndex);

      meetingMessages += `
        <hr>
        <div class="roles-reveal-content">
          <h3>ü™¶ ${sheriff.name} the Sheriff shot an innocent person and died!</h3>
        </div>
      `;

      if (loverDeathIndex !== null) {
        const lover = players[loverDeathIndex];
        meetingMessages += `
          <div class="lover-death-message">
            <h3>üíî ${lover.name} collapsed from heartbreak...</h3>
          </div>
        `;
      }
    }
  }

  sheriffShotTarget = null;
}

  // =====================================================
  // üõ° PHASE 4 ‚Äî RESOLVE VOTE
  // =====================================================

  let screenHTML = "";

  // ‚öñÔ∏è Tie
  if (eliminatedIndex === null) {

    screenHTML = `
      <div class="roles-reveal-header">
        <h2>‚öñÔ∏è It's a Tie!</h2>
      </div>
      <div class="roles-reveal-content">
        <p>No one is eliminated by vote.</p>
      </div>
    `;

  } else {

    const eliminatedPlayer = players[eliminatedIndex];

    // üé≠ Jester
    if (eliminatedPlayer.role === "Jester") {
      endGame(
        `<strong>${eliminatedPlayer.name} the Jester wins!</strong>`,
        "Jester"
      );
      return;
    }

    // üõ° Shield logic
    if (eliminatedPlayer.role === "Shield") {

      // üî• If hunter killed them first
      if (!eliminatedPlayer.alive) {

        screenHTML = `
          <div class="roles-reveal-header">
            <h2 style="color:${roleColors["Shield"]}">
              üõ°Ô∏è ${eliminatedPlayer.name}'s Shield shattered...
            </h2>
          </div>
          <div class="roles-reveal-content">
            <p>The Shield was cut down before it could activate.</p>
          </div>
        `;

      } else {

        // Shield activates normally
        // (Keep your existing shield retaliation logic here)
        // Just render it and return early

        renderShieldRetaliation(eliminatedIndex);
        return;
      }

    } else {

      // üó≥ Normal elimination
      if (eliminatedPlayer.alive) {
        eliminatedPlayer.alive = false;
        if (
  hunterMarkedTarget !== null &&
  !players[hunterMarkedTarget]?.alive
) {
  hunterMarkedTarget = null;
}
        handleLoverChainDeath(eliminatedIndex);
      }

      screenHTML = `
        <div class="roles-reveal-header">
          <h2>${eliminatedPlayer.name} has been voted!</h2>
        </div>
        <div class="roles-reveal-content">
          <p>
            They were the 
            <span style="color:${roleColors[eliminatedPlayer.role]}; font-weight:bold;">
              ${eliminatedPlayer.role}
            </span>
          </p>
        </div>
      `;
    }
  }

  // =====================================================
  // üé® PHASE 5 ‚Äî RENDER EVERYTHING
  // =====================================================

  votingBox.innerHTML = screenHTML;

  // Vote summary
votingBox.innerHTML += `
  <div class="vote-summary">
    <hr>
    <h3>üó≥Ô∏è Vote Results</h3>
    ${Object.keys(votes).map(i => `
      <p>
        <strong>${players[i].name}</strong> - ${votes[i]} vote${votes[i] !== 1 ? "s" : ""}
      </p>
    `).join("")}
  </div>
`;

  // Meeting messages (poison + hunter)
  votingBox.innerHTML += meetingMessages;

  // Continue button
  clearContinueButtons();
  const btn = document.createElement("button");
  btn.textContent = "Continue";
  btn.className = "reveal-roles-btn";
  btn.onclick = () => nextRound();
  votingBox.appendChild(btn);

}

function renderShieldRetaliation(eliminatedIndex) {

  const eliminatedPlayer = players[eliminatedIndex];

  const voters = players
    .map((player, index) => ({ player, index }))
    .filter(obj => obj.player.alive && obj.player.vote === eliminatedIndex);

  if (voters.length === 0) {

    votingBox.innerHTML = `
      <div class="roles-reveal-header">
        <h2>${eliminatedPlayer.name} was voted!</h2>
      </div>
      <div class="roles-reveal-content">
        <p>But no one can be punished.</p>
      </div>
    `;

    addContinueButton();
    return;
  }

  votingBox.innerHTML = `
    <div class="roles-reveal-header">
      <h2 style="color:${roleColors["Shield"]}">
        üõ°Ô∏è ${eliminatedPlayer.name}'s Shield activates!
      </h2>
      <p>Choose one player to eliminate:</p>
    </div>
    <div class="roles-reveal-content" id="shieldOptions"></div>
  `;

  const shieldOptions = document.getElementById("shieldOptions");

  voters.forEach(obj => {

    const btn = document.createElement("button");
    btn.textContent = obj.player.name;
    btn.className = "reveal-roles-btn";

    btn.onclick = () => {

  const killedPlayer = obj.player;
  killedPlayer.alive = false;
  if (
  hunterMarkedTarget !== null &&
  !players[hunterMarkedTarget]?.alive
) {
  hunterMarkedTarget = null;
}

  const loverDeathIndex = handleLoverChainDeath(obj.index);

  // Replace screen with retaliation result
  votingBox.innerHTML = `
    <div class="roles-reveal-header">
      <h3 style="color:${roleColors["Shield"]}">
        üõ°Ô∏è ${eliminatedPlayer.name} retaliates!
      </h3>
    </div>
    <div class="roles-reveal-content">
      <h3>${killedPlayer.name} has been smushed into pieces!</h3>
      <p>
        They were the 
        <span style="color:${roleColors[killedPlayer.role]}; font-weight:bold;">
          ${killedPlayer.role}
        </span>
      </p>
    </div>
  `;

  if (loverDeathIndex !== null) {
    const lover = players[loverDeathIndex];
    votingBox.innerHTML += `
      <div class="lover-death-message">
        <h3>üíî ${lover.name} collapsed from heartbreak...</h3>
      </div>
    `;
  }

  // ‚úÖ Add Continue button HERE
   votingBox.innerHTML += meetingMessages;
  const continueBtn = document.createElement("button");
  continueBtn.textContent = "Continue";
  continueBtn.className = "reveal-roles-btn";
  continueBtn.style.marginTop = "15px";
  continueBtn.onclick = () => nextRound();

  votingBox.appendChild(continueBtn);
};

    shieldOptions.appendChild(btn);
  });
}

function resolveSheriffAfterShield() {

  const sheriff = players.find(p => p.role === "Sheriff");
  const target = players[sheriffShotTarget];

  // If no sheriff action, just show continue
  if (sheriffShotTarget === null || !target || !target.alive) {
    sheriffShotTarget = null;
    addFinalContinueButton();
    return;
  }

  // üé≠ Jester instant win
  if (target.role === "Jester") {
    endGame(
      `<strong>${target.name} the Jester wins!</strong><br>
       They were shot by the Sheriff!`,
      "Jester"
    );
    return;
  }

  let loverDeathIndex = null;

  if (sheriffAllowedRoles.includes(target.role)) {

    target.alive = false;
    if (
  hunterMarkedTarget !== null &&
  !players[hunterMarkedTarget]?.alive
) {
  hunterMarkedTarget = null;
}
    loverDeathIndex = handleLoverChainDeath(sheriffShotTarget);

    votingBox.innerHTML += `
      <hr>
      <h3>üî´ ${target.name} was shot by the Sheriff!</h3>
      <p>
        They were the 
        <span style="color:${roleColors[target.role]}; font-weight:bold;">
          ${target.role}
        </span>
      </p>
    `;

  } else {

    sheriff.alive = false;
    if (
  hunterMarkedTarget !== null &&
  !players[hunterMarkedTarget]?.alive
) {
  hunterMarkedTarget = null;
}
    const sheriffIndex = players.findIndex(p => p.role === "Sheriff");
    loverDeathIndex = handleLoverChainDeath(sheriffIndex);

    votingBox.innerHTML += `
      <hr>
      <h3>‚ùå The Sheriff shot the wrong person and died!</h3>
    `;
  }

  if (loverDeathIndex !== null) {
    const lover = players[loverDeathIndex];
    votingBox.innerHTML += `
      <div class="lover-death-message">
        <hr>
        <h3>üíî ${lover.name} could not live without their lover...</h3>
      </div>
    `;
  }

  sheriffShotTarget = null;

  addFinalContinueButton();
}

function addFinalContinueButton() {

  if (checkWinCondition()) return;

clearContinueButtons();

  const continueBtn = document.createElement("button");
  continueBtn.textContent = "Continue";
  continueBtn.className = "reveal-roles-btn";
  continueBtn.style.marginTop = "15px";

  continueBtn.onclick = () => {
    hunterPendingKillIndex = null;
    nextRound();
  };

  votingBox.appendChild(continueBtn);
}

function nextRound() {

  // üîÑ Reset per-round vote data
  players.forEach(player => {
    player.vote = null;
  });

  votes = {};
  currentVoterIndex = 0;

  dictatorBlockedPlayer = null;
  sheriffShotTarget = null;
  viperChoosingPoison = false;

  // üèπ Hunter reset (only if ability already used)
  hunterPendingKill = null;

  // üßº Clear voting box
  votingBox.innerHTML = "";

  // üèÅ Check win condition first
  if (checkWinCondition()) return;

  // ‚ñ∂Ô∏è Start next voting phase
  startVotingPhase();
}

function checkWinCondition() {

  const alivePlayers = players.filter(p => p.alive);

  const jackalAlive = alivePlayers.find(p => p.role === "Jackal");
  const viperAlive  = alivePlayers.find(p => p.role === "Viper");

const mainEvilRoles = ["Imposter", "Dictator", "Mastermind", "Hunter"];

const impostorsAlive = alivePlayers.filter(p =>
  mainEvilRoles.includes(p.role) ||
  ["Maniac","Shadow","Cultist"].includes(p.role)
);

  const crewAlive = alivePlayers.filter(p =>
    !["Imposter","Dictator","Mastermind","Hunter","Jackal","Viper"].includes(p.role)
  );

  /* ==============================
     üëπ IMPOSTORS WIN
     ============================== */

  if (
    !jackalAlive &&
    !viperAlive &&
    impostorsAlive.length > 0 &&
    impostorsAlive.length >= crewAlive.length
  ) {
    endGame(`<strong>Evil wins!</strong>`, "Imposter");
    return true;
  }

  /* ==============================
     üê∫ JACKAL WIN
     ============================== */

  if (jackalAlive) {

    const nonJackalAlive = alivePlayers.filter(p => p.role !== "Jackal");

    // Jackal alone
    if (nonJackalAlive.length === 0) {
      endGame(`<strong>${jackalAlive.name} the Jackal wins alone!</strong>`, "Jackal");
      return true;
    }

    // Jackal + 1 crew
    if (
      nonJackalAlive.length === 1 &&
      !["Imposter","Dictator","Mastermind","Hunter","Viper"].includes(nonJackalAlive[0].role)
    ) {
      endGame(`<strong>${jackalAlive.name} the Jackal wins!</strong>`, "Jackal");
      return true;
    }
  }

  /* ==============================
     üêç VIPER WIN
     ============================== */

  if (viperAlive) {

    const nonViperAlive = alivePlayers.filter(p => p.role !== "Viper");

    // Viper alone
    if (nonViperAlive.length === 0) {
      endGame(`<strong>${viperAlive.name} the Viper wins alone!</strong>`, "Viper");
      return true;
    }

    // Viper + 1 crew
    if (
      nonViperAlive.length === 1 &&
      !["Imposter","Dictator","Mastermind","Hunter","Jackal"].includes(nonViperAlive[0].role)
    ) {
      endGame(`<strong>${viperAlive.name} the Viper wins!</strong>`, "Viper");
      return true;
    }
  }

  /* ==============================
     üë• CREW WIN
     ============================== */

  if (
    impostorsAlive.length === 0 &&
    !jackalAlive &&
    !viperAlive
  ) {
    endGame(`<strong>Crew wins!</strong>`, "Crew");
    return true;
  }

  return false;
}

function shadeColor(color, percent) {
  let R = parseInt(color.substring(1,3),16);
  let G = parseInt(color.substring(3,5),16);
  let B = parseInt(color.substring(5,7),16);

  R = parseInt(R * (100 + percent) / 100);
  G = parseInt(G * (100 + percent) / 100);
  B = parseInt(B * (100 + percent) / 100);

  R = (R<255)?R:255;  
  G = (G<255)?G:255;  
  B = (B<255)?B:255;  

  const RR = ((R.toString(16).length==1)?"0":"")+R.toString(16);
  const GG = ((G.toString(16).length==1)?"0":"")+G.toString(16);
  const BB = ((B.toString(16).length==1)?"0":"")+B.toString(16);

  return "#"+RR+GG+BB;
}

function endGame(message, winningRole = null) {

  let color = "#ffffff";

  if (winningRole && roleColors[winningRole]) {
    color = roleColors[winningRole];
  }

  const darker = shadeColor(color, -60);
  const lighter = shadeColor(color, 20);

  votingBox.innerHTML = `
    <div class="roles-reveal-header win-header">
      <h2 style="color:white; text-shadow: 0 0 12px ${color};">
        ${message}
      </h2>
    </div>
    <div class="roles-reveal-content">
      <button onclick="location.reload()" class="reveal-roles-btn">
        New Game
      </button>
    </div>
  `;

  const header = votingBox.querySelector(".win-header");

  header.style.background = `
    linear-gradient(45deg, ${color}, ${darker}, ${lighter}, ${color})
  `;
  header.style.backgroundSize = "400% 400%";
  header.style.animation = "gradientShift 10s linear infinite";
  const revealBtn = document.getElementById("revealRolesBtn");
  if (revealBtn) {
    revealBtn.style.display = "block";
  }
}
/* ===== HELPER FUNCTIONS ===== */
function getRandomItemFromArray(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function saveRoleToggles() {

  const toggles = document.querySelectorAll("input[type='checkbox']");

  const toggleStates = {};

  toggles.forEach(toggle => {
    toggleStates[toggle.id] = toggle.checked;
  });

  localStorage.setItem("roleToggles", JSON.stringify(toggleStates));
}

function loadRoleToggles() {

  const saved = JSON.parse(localStorage.getItem("roleToggles"));

  if (!saved) return;

  Object.keys(saved).forEach(id => {

    const toggle = document.getElementById(id);
    if (toggle) {
      toggle.checked = saved[id];
    }

  });
}

document.addEventListener("DOMContentLoaded", () => {

  loadRoleToggles();

  const toggles = document.querySelectorAll("input[type='checkbox']");
  toggles.forEach(toggle => {
    toggle.addEventListener("change", saveRoleToggles);
  });

});

const roleToggleMap = {
  Philosopher: "philosopherToggle",
  Sheriff: "sheriffToggle",
  Detective: "detectiveToggle",
  Clueless: "cluelessToggle",
  Echo: "echoToggle",
  Idiot: "idiotToggle",
  Shield: "shieldToggle",

  Imposter: "imposterToggle",
  Dictator: "dictatorToggle",
  Mastermind: "mastermindToggle",
  Hunter: "hunterToggle",

  Maniac: "maniacToggle",
  Cultist: "cultistToggle",
  Shadow: "shadowToggle",

  Jester: "jesterToggle",
  Jackal: "jackalToggle",
  Viper: "viperToggle",
  Assassin: "assassinToggle",

  King: "kingToggle",
  Lovers: "loversToggle"
};

function getEnabledRoles() {

  const enabledRoles = [];

  for (let role in roleToggleMap) {

    const toggleId = roleToggleMap[role];
    const toggle = document.getElementById(toggleId);

    if (toggle && toggle.checked) {
      enabledRoles.push(role);
    }
  }

  return enabledRoles;
}

function updateRoleAvailability() {
  const allToggles = document.querySelectorAll('.role-pill input[type="checkbox"]');

  // Never disable anything
  allToggles.forEach(toggle => {
    toggle.disabled = false;
  });
}

function updateRoleVisuals() {

  document.querySelectorAll('.role-pill').forEach(pill => {

    const checkbox = pill.querySelector('input[type="checkbox"]');
    if (!checkbox) return;

    const roleName = pill.innerText.trim();

    // Reset classes first
    pill.classList.remove("enabled", "disabled");

    if (checkbox.checked) {
      pill.classList.add("enabled");

      if (roleColors[roleName]) {
        pill.style.borderColor = roleColors[roleName];
      }

    } else if (checkbox.disabled) {
      // ONLY disabled if the checkbox itself is disabled
      pill.classList.add("disabled");
      pill.style.borderColor = "transparent";

    } else {
      // Normal unchecked but still clickable
      pill.style.borderColor = "transparent";
    }

  });
}

/* ===== MAIN GAME FUNCTION ===== */
function generateCards() {
dictatorBlockedPlayer = null;
sheriffShotTarget = null;
hunterMarkedTarget = null;
hunterChoosingIndex = null;

  startVotingBtn.style.display = "none";
startVotingBtn.classList.remove("show");

// Reset reveal + voting UI
firstPlayerBox.classList.remove("show");
firstPlayerBox.textContent = "";

votingBox.innerHTML = "";
votingBox.style.display = "none";

startVotingBtn.style.display = "none";

revealedCards = 0;
lockedCards = 0;
firstPlayerBox.classList.remove("show");
firstPlayerBox.textContent = "";

  if (!currentSubject || customItems.length === 0) {
    errorBox.textContent = "Please select a subject first";
    return;
  }
  
  // Reset state
  revealedCards = 0;
  lockedCards = 0;
  playerNumbers = [];
  isDetectiveChoosing = false; 
  activeDetectiveCardElement = null;
  document.body.classList.remove('detective-mode');

  firstPlayerBox.classList.remove('show');
  firstPlayerBox.textContent = '';
  revealRolesBtn.style.display = 'none';
  rolesRevealBox.classList.remove('show');
  rolesRevealBox.innerHTML = '';
  kingAnnouncement.classList.remove('show');
  kingAnnouncement.textContent = '';
  errorBox.textContent = "";
  kingPlayer = null;
  loverIndexes = null;
  cluelessWord = "";

  const playerCount = parseInt(playerSlider.value, 10);
  const imposterCount = parseInt(imposterSlider.value, 10);

  if (playerCount < 3) {
    errorBox.textContent = "There must be at least 3 players.";
    return;
  }

  if (imposterCount < 1) {
    errorBox.textContent = "At least 1 imposter.";
    return;
  }

  if (imposterCount >= playerCount) {
    errorBox.textContent = "Imposters must be less than total players.";
    return;
  }

  // Save settings
  localStorage.setItem("playerCount", playerCount);
  localStorage.setItem("imposterCount", imposterCount);

  // Logic setup (Word/Category selection)
  secretItem = getRandomItemFromArray(customItems);
  
  // Determine Category Display
  secretCategory = "Common";
  let categoryItems = [];

  // Check saved custom subjects first
  if (savedCustomSubjects[currentSubject]) {
    // The subject object looks like { "Category1": [words], "Category2": [words] }
    // We need to find which category the secretItem belongs to
    let found = false;
    for (const [category, items] of Object.entries(savedCustomSubjects[currentSubject])) {
      if (items.includes(secretItem)) {
        secretCategory = category;
        categoryItems = items;
        found = true;
        break;
      }
    }
    // Fallback if random selection logic had a hiccup (shouldn't happen)
    if (!found) {
       const firstKey = Object.keys(savedCustomSubjects[currentSubject])[0];
       secretCategory = firstKey || "Custom List";
       categoryItems = savedCustomSubjects[currentSubject][firstKey] || customItems;
    }
  } 
  // Then check default subjects
  else if (defaultSubjects[currentSubject]) {
    for (const [category, items] of Object.entries(defaultSubjects[currentSubject])) {
      if (items.includes(secretItem)) {
        secretCategory = category;
        categoryItems = items;
        break;
      }
    }
  } 
  // Single use custom word
  else {
    secretCategory = "Custom";
    categoryItems = customItems;
  }

  // Determine active roles
  let useDetective = detectiveToggle.checked;
  let useJester = jesterToggle.checked;
  let useJackal = jackalToggle.checked;
  let useViper = viperToggle.checked;
  let useShield = shieldToggle.checked;
  let useAssassin = assassinToggle.checked;
  let useClueless = cluelessToggle.checked;
  let useEcho = echoToggle.checked;
  let useIdiot = idiotToggle.checked;
  let usePhilosopher = philosopherToggle.checked;
  let useSheriff = sheriffToggle.checked;
  let useManiac = maniacToggle.checked;
  let useCultist = cultistToggle.checked;
  let useShadow = shadowToggle.checked;
  let useKing = kingToggle.checked;
  let useLovers = loversToggle.checked;

  // RANDOMIZE LOGIC
  if (randomizeToggle.checked) {
 // 1Ô∏è‚É£ Reset all
useDetective = false;
useJester = false;
useJackal = false;
useViper = false;
useShield = false;
useAssassin = false;
useClueless = false;
useEcho = false;
useIdiot = false;
usePhilosopher = false;
useSheriff = false;
useManiac = false;
useCultist = false;
useShadow = false;
useKing = false;
useLovers = false;

// 2. Calculate available slots (non-imposters)
const civilianSlots = playerCount - imposterCount;

// 3. Build role pool
let rolePool = [];

if (detectiveToggle.checked) rolePool.push('detective');
if (jesterToggle.checked) rolePool.push('jester');
if (jackalToggle.checked) rolePool.push('jackal');
if (viperToggle.checked) rolePool.push('viper');
if (assassinToggle.checked) rolePool.push('assassin');
if (shieldToggle.checked) rolePool.push('shield');
if (echoToggle.checked) rolePool.push('echo');
if (idiotToggle.checked) rolePool.push('idiot');
if (philosopherToggle.checked) rolePool.push('philosopher');
if (sheriffToggle.checked) rolePool.push('sheriff');
if (maniacToggle.checked) rolePool.push('maniac');
if (cultistToggle.checked) rolePool.push('cultist');
if (shadowToggle.checked) rolePool.push('shadow');

if (cluelessToggle.checked && categoryItems.length >= 2) {
  rolePool.push('clueless');
}

const crewPool = rolePool.filter(r => roleData[r] && roleData[r].team === "Crew");
const evilPool = rolePool.filter(r => roleData[r] && roleData[r].team === "Evil");
const neutralPool = rolePool.filter(r => roleData[r] && roleData[r].team === "Neutral");

// Shuffle role pool
for (let i = rolePool.length - 1; i > 0; i--) {
  const j = Math.floor(Math.random() * (i + 1));
  [rolePool[i], rolePool[j]] = [rolePool[j], rolePool[i]];
}


// Shuffle helper
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

shuffle(crewPool);
shuffle(evilPool);
shuffle(neutralPool);

// Final selected roles
let selectedRoles = [];

// üü¢ STEP 1 ‚Äî FORCE CREW ROLES BASED ON PLAYER COUNT

const minCrewRequired = playerCount > 3 ? 2 : 1;

for (let i = 0; i < minCrewRequired; i++) {
  if (
    crewPool.length > 0 &&
    selectedRoles.length < civilianSlots
  ) {
    selectedRoles.push(crewPool.shift());
  }
}
// üü¢ STEP 2 ‚Äî Fill remaining slots with everything else
let remainingPool = [...crewPool, ...evilPool, ...neutralPool];
shuffle(remainingPool);

while (
  selectedRoles.length < civilianSlots &&
  remainingPool.length > 0
) {
  selectedRoles.push(remainingPool.shift());
}

// üü¢ STEP 3 ‚Äî Enable roles
selectedRoles.forEach(role => {
  if (role === 'detective') useDetective = true;
  if (role === 'jester') useJester = true;
  if (role === 'jackal') useJackal = true;
  if (role === 'viper') useViper = true;
  if (role === 'shield') useShield = true;
  if (role === 'assassin') useAssassin = true;
  if (role === 'clueless') useClueless = true;
  if (role === 'echo') useEcho = true;
  if (role === 'idiot') useIdiot = true;
  if (role === 'philosopher') usePhilosopher = true;
  if (role === 'sheriff') useSheriff = true;
  if (role === 'maniac') useManiac = true;
  if (role === 'cultist') useCultist = true;
  if (role === 'shadow') useShadow = true;
});
// üü¢ STEP 4 ‚Äî Add-ons (DO NOT consume slots)

// üé≤ Add-ons (50% activation chance)

// ‚ù§Ô∏è Lovers
if (loversToggle.checked && playerCount >= 2) {
  useLovers = Math.random() < 0.33;
} else {
  useLovers = false;
}

// üëë King
if (kingToggle.checked) {
  useKing = Math.random() < 0.5;
} else {
  useKing = false;
}
  } else {
      // Manual mode validation
      const civilianSlots = playerCount - imposterCount;
      let specialRolesCount = 0;
      if (useDetective) specialRolesCount++;
      if (useJester) specialRolesCount++;
      if (useJackal) specialRolesCount++;
      if (useViper) specialRolesCount++;
      if (useShield) specialRolesCount++;
      if (useAssassin) specialRolesCount++;
      if (useClueless) specialRolesCount++;
      if (useEcho) specialRolesCount++;
      if (useIdiot) specialRolesCount++;
      if (usePhilosopher) specialRolesCount++;
      if (useSheriff) specialRolesCount++;
      if (useManiac) specialRolesCount++;
      if (useCultist) specialRolesCount++;
      if (useShadow) specialRolesCount++;
      
      if (civilianSlots < specialRolesCount + 1) { 
        errorBox.textContent = `Need at least ${specialRolesCount + 1} non-imposters for special roles.`;
        return;
      }
      
      if (useClueless && categoryItems.length < 2) {
          errorBox.textContent = "Clueless role disabled: Not enough words in this category.";
          return;
      }
  }

  // --- ROLE ASSIGNMENT LOGIC ---
  words = Array(playerCount).fill("Civilian");

let activeMainEvil = "Imposter"; // fallback

if (randomizeToggle.checked) {
  const shuffled = [...mainEvilRoles];
  shuffled.sort(() => Math.random() - 0.5);
  activeMainEvil = shuffled[0];
}

// üî¥ BUILD MAIN EVIL POOL BASED ON TOGGLES
let mainEvilPool = [];

if (imposterToggle.checked) {
  mainEvilPool.push("Imposter");
}

if (dictatorToggle.checked) {
  mainEvilPool.push("Dictator");
}

if (mastermindToggle.checked) {
  mainEvilPool.push("Mastermind");
}

if (hunterToggle.checked) {
  mainEvilPool.push("Hunter");
}

// SAFETY: If nothing enabled, default to Impostor
if (mainEvilPool.length === 0) {
  mainEvilPool.push("Imposter");
}

// üî¥ MAIN EVIL ASSIGNMENT
let imposters = 0;

while (imposters < imposterCount) {

  const idx = Math.floor(Math.random() * playerCount);

  if (words[idx] === "Civilian") {

    // Pick random enabled main evil
    const chosenEvil =
      mainEvilPool[Math.floor(Math.random() * mainEvilPool.length)];

    words[idx] = chosenEvil;

    imposterIndex = idx; // still works for first evil
    imposters++;
  }
}

// Evil helper roles (can only have ONE)
const evilHelperPool = [];

if (useManiac) evilHelperPool.push("Maniac");
if (useCultist) evilHelperPool.push("Cultist");
if (useShadow) evilHelperPool.push("Shadow");
// Add future helper roles here
// if (useSomeNewRole) evilHelperPool.push("SomeNewRole");

let selectedEvilHelper = null;

if (evilHelperPool.length > 0) {
  const randomIndex = Math.floor(Math.random() * evilHelperPool.length);
  selectedEvilHelper = evilHelperPool[randomIndex];
}
useManiac = selectedEvilHelper === "Maniac";
useCultist = selectedEvilHelper === "Cultist";
useShadow = selectedEvilHelper === "Shadow";

  // Detective
  let detectiveIndex = null;
  if (useDetective) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Detective";
        detectiveIndex = idx;
        assigned = true;
      }
    }
  }

  // Jester
  if (useJester) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Jester";
        assigned = true;
      }
    }
  }

  // Jackal
  if (useJackal) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Jackal";
        assigned = true;
      }
    }
  }

  // Viper
  if (useViper) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Viper";
        assigned = true;
      }
    }
  }

  // Shield
  if (useShield) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Shield";
        assigned = true;
      }
    }
  }

  // Clueless
  if (useClueless) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Clueless";
        assigned = true;
        const potentialCluelessWords = categoryItems.filter(item => item !== secretItem);
        cluelessWord = getRandomItemFromArray(potentialCluelessWords);
      }
    }
  }
    // Echo
  if (useEcho) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Echo";
        assigned = true;
      }
    }
  }
  // Idiot
  if (useIdiot) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Idiot";
        assigned = true;
      }
    }
  }
  // Philosopher
  if (usePhilosopher) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Philosopher";
        assigned = true;
      }
    }
  }
  // Sheriff
  if (useSheriff) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Sheriff";
        assigned = true;
      }
    }
  }
      // Maniac
  if (useManiac) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Maniac";
        assigned = true;
      }
    }
  }
       // Cultist
  if (useCultist) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Cultist";
        assigned = true;
      }
    }
  }
// Shadow
  if (useShadow) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Shadow";
        assigned = true;
      }
    }
  }

  // Assassin
  let assassinIndex = null;
  assassinTarget = null;
  if (useAssassin) {
    let assigned = false;
    while (!assigned) {
      const idx = Math.floor(Math.random() * playerCount);
      if (words[idx] === "Civilian") {
        words[idx] = "Assassin";
        assassinIndex = idx;
        const possibleTargets = [];
        for (let i = 0; i < playerCount; i++) {
          if (i !== idx && words[i] !== "Imposter" && words[i] !== "Dictator" && words[i] !== "Mastermind"  && words[i] !== "Hunter") {
            possibleTargets.push(i);
          }
        }
        if (possibleTargets.length > 0) {
          const targetIdx = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
          assassinTarget = targetIdx + 1;
          assigned = true;
        } else {
          words[idx] = "Civilian"; 
        }
      }
    }
  }

  // King
  if (useKing) {
    kingPlayer = Math.floor(Math.random() * playerCount);
  }

    loverIndexes = [];

if (useLovers && playerCount >= 2) {
  while (loverIndexes.length < 2) { 
    const randomIndex = Math.floor(Math.random() * playerCount);

    if (!loverIndexes.includes(randomIndex)) {
      loverIndexes.push(randomIndex);
    }
  }
}
  

  // Fill Civilians
  for (let i = 0; i < words.length; i++) {
    if (words[i] === "Civilian") {
      words[i] = secretItem;
    }
  }

  // SHUFFLE
  const indices = Array.from({length: playerCount}, (_, i) => i);
  for (let i = indices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }
  const shuffledWords = indices.map(i => words[i]);
  words = shuffledWords;

  initializePlayers();

  // Re-map Assassin Target & King
  if (useAssassin && assassinIndex !== null && assassinTarget !== null) {
    let newAssassinIndex = null;
    for (let i = 0; i < indices.length; i++) {
      if (indices[i] === assassinIndex) { newAssassinIndex = i; break; }
    }
    let newTargetIndex = null;
    const originalTargetIndex = assassinTarget - 1;
    for (let i = 0; i < indices.length; i++) {
      if (indices[i] === originalTargetIndex) { newTargetIndex = i; break; }
    }
    
    if (newAssassinIndex !== null && newTargetIndex !== null && newAssassinIndex === newTargetIndex) {
      for (let i = 0; i < words.length; i++) {
        if (i !== newAssassinIndex && words[i] !== "Imposter" && words[i] !== "Dictator" && words[i] !== "Mastermind" && words[i] !== "Hunter"  && words[i] !== "Detective" && words[i] !== "Jester" && words[i] !== "Jackal" && words[i] !== "Viper"  && words[i] !== "Shield" && words[i] !== "Assassin" && words[i] !== "Clueless" && words[i] !== "Echo" && words[i] !== "Idiot" && words[i] !== "Philosopher" && words[i] !== "Sheriff" && words[i] !== "Maniac" && words[i] !== "Cultist" && words[i] !== "Shadow" ) {
          [words[newAssassinIndex], words[i]] = [words[i], words[newAssassinIndex]];
          assassinTarget = i + 1;
          break;
        }
      }
    } else if (newTargetIndex !== null) {
      assassinTarget = newTargetIndex + 1;
    }
  }
  
  if (useKing && kingPlayer !== null) {
    let newKingIndex = null;
    for (let i = 0; i < indices.length; i++) {
      if (indices[i] === kingPlayer) { newKingIndex = i; break; }
    }
    kingPlayer = newKingIndex;
  }



function initializePlayers() {
  players = [];

  for (let i = 0; i < playerCount; i++) {

    let roleName = words[i];

    // If it's not a special role, it's Civilian
    const specialRoles = [
      "Imposter","Dictator","Mastermind","Hunter","Detective","Jester","Jackal","Viper", "Shield",
      "Assassin","Clueless","Echo","Idiot","Philosopher",
      "Maniac","Cultist","Shadow","Sheriff"
    ];

    if (!specialRoles.includes(roleName)) {
      roleName = "Civilian";
    }

    players.push({
      name: playerNames[i] || `Player ${i + 1}`,
      role: roleName,
      word: words[i],   // what they actually see
      alive: true,
      vote: null,
      isLover: loverIndexes.includes(i)
    });
  }
}


  // --- CARD GENERATION ---
  cardsContainer.innerHTML = "";
  totalCards = playerCount;
  updateTracker();

  words.forEach((word, i) => {
    const playerNumber = i + 1;
    const playerName = playerNames[i] || `Player ${playerNumber}`;
    playerNumbers.push(playerNumber);

    const card = document.createElement("div");
    card.className = "card";
    card.dataset.index = i; // Store index for detective logic

    card.innerHTML = `
      <div class="card-header">
        <span>${playerName}</span>
        <span class="status-label">Hidden</span>
      </div>
      <div class="word-box word-hidden"></div>
      <div class="category-box"></div>
      <button class="card-btn">Reveal</button>
    `;

    const wordBox = card.querySelector(".word-box");
    const categoryBox = card.querySelector(".category-box");
    const btn = card.querySelector(".card-btn");
    const statusLabel = card.querySelector(".status-label");

    let viewed = false;
    let revealed = false;
    let specialHint = null;

    // --- DETECTIVE CLICK HANDLER (ON THE CARD ITSELF) ---
    // This handles the click when the detective selects THIS card as a target
    card.addEventListener('click', (e) => {
if (hunterChoosingIndex !== null && i !== hunterChoosingIndex) {

  hunterMarkedTarget = i;

  const status = document.querySelector(".hunter-status");

if (status) {
  status.innerHTML = `<strong>Target - ${playerNames[i]}</strong>`;
}

  return;
}
      // Only trigger if detective is currently choosing, this card isn't the detective's, and it's not the button being clicked
      if (isDetectiveChoosing && e.target !== btn && !card.classList.contains('detective-active-card')) {
        
        // 1. Identify role of this target
        const targetWord = words[i];
        let roleReveal = "Civilian";
        
        if (targetWord === "Imposter") roleReveal = "Evil";
        else if (targetWord === "Dictator") roleReveal = "Evil";
        else if (targetWord === "Mastermind") roleReveal = "Evil";
        else if (targetWord === "Hunter") roleReveal = "Evil";
        else if (targetWord === "Jester") roleReveal = "Mentally ill";
        else if (targetWord === "Jackal") roleReveal = "Evil";
        else if (targetWord === "Viper") roleReveal = "Evil";
        else if (targetWord === "Shield") roleReveal = "a Shield";
        else if (targetWord === "Assassin") roleReveal = "Evil";
        else if (targetWord === "Clueless") roleReveal = "Crew";
        else if (targetWord === "Echo") roleReveal = "an Echo";
        else if (targetWord === "Idiot") roleReveal = "Mentally ill";
        else if (targetWord === "Philosopher") roleReveal = "a Philosopher";
        else if (targetWord === "Sheriff") roleReveal = "a Sheriff";
        else if (targetWord === "Maniac") roleReveal = "Mentally ill";
        else if (targetWord === "Cultist") roleReveal = "Mentally ill";
        else if (targetWord === "Shadow") roleReveal = "Evil";
        else if (targetWord === "Detective") roleReveal = "Detective"; // Should be impossible if logic holds
        else roleReveal = "Crew"; // Or the secret word

        // 2. Update the Detective's card hint
        if (activeDetectiveHintElement) {
          activeDetectiveHintElement.innerHTML = `
            <strong>Your Mission:</strong><br>Find imposters!<br><br>
            <strong>Investigation Result:</strong><br>
            <span style="color:#10b981; font-size:1.1em">${playerName} is ${roleReveal}</span>
          `;
          activeDetectiveHintElement.style.border = "2px solid #10b981";
          activeDetectiveHintElement.style.background = "#fff";
        }

        // 3. Reset Detective Mode
        isDetectiveChoosing = false;
        document.body.classList.remove('detective-mode');
        
        // Remove highlighting from all cards
        document.querySelectorAll('.card').forEach(c => {
          c.classList.remove('detective-active-card');
        });
      }
    });


    // --- STANDARD BUTTON HANDLER ---
    btn.addEventListener("click", (e) => {
      e.stopPropagation(); // Prevent triggering the card click event
      if (viewed) return;

      // Reveal Logic
      if (btn.textContent === "Reveal") {
        
        // Render Role Text
        if (word === "Imposter") {
          wordBox.textContent = "???";
          const roleText = document.createElement("div");
          roleText.className = "imposter-role";
          roleText.textContent = "Imposter";
          wordBox.appendChild(roleText);
        } else if (word === "Dictator") {
          wordBox.textContent = "???";
          const roleText = document.createElement("div");
          roleText.className = "dictator-role";
          roleText.textContent = "Dictator";
          wordBox.appendChild(roleText);
        } else if (word === "Mastermind") {

  wordBox.textContent = "???";

  const roleText = document.createElement("div");
  roleText.className = "mastermind-role";
  roleText.textContent = "Mastermind";
  wordBox.appendChild(roleText);

  // üß† MASTER VISION
  const visionBox = document.createElement("div");
  visionBox.className = "mastermind-vision";

  let rolesHTML = `<strong>All Player Roles:</strong><br><br>`;

  players.forEach((player) => {

  const color = roleColors[player.role] || "#ffffff";

  const isCivilian = player.role === "Civilian";

  rolesHTML += `
    <div class="mastermind-player-role">
      ${player.name}: 
      <span 
        style="
          color:${color};
          font-weight:bold;
          ${!isCivilian ? `
            text-shadow:
              -1px -1px 0 #fff,
               1px -1px 0 #fff,
              -1px  1px 0 #fff,
               1px  1px 0 #fff;
          ` : ""}
        "
      >
        ${player.role}
      </span>
    </div>
  `;
});

  visionBox.innerHTML = rolesHTML;

  wordBox.appendChild(visionBox);
       } else if (word === "Hunter") {

  wordBox.textContent = "???";

  const roleText = document.createElement("div");
  roleText.className = "hunter-role";
  roleText.textContent = "Hunter";
  wordBox.appendChild(roleText);

  hunterChoosingIndex = i;

  const hunterHint = document.createElement("div");
  hunterHint.className = "hunter-hint show"; // show immediately

  hunterHint.innerHTML = `
    <strong>Your Mission:</strong><br>
    Survive and trick everyone!<br><br>
    You can select a <strong>target</strong> and later during voting decide if you want to kill them!<br><br>
    <div class="hunter-status"><strong>Choose your prey.</strong></div>
  `;

  card.appendChild(hunterHint);

        } else if (word === "Detective") {
          wordBox.textContent = secretItem;
          const roleText = document.createElement("div");
          roleText.className = "detective-role";
          roleText.textContent = "Detective";
          wordBox.appendChild(roleText);
        } else if (word === "Jester") {
          wordBox.textContent = secretItem;
          const roleText = document.createElement("div");
          roleText.className = "jester-role";
          roleText.textContent = "Jester";
          wordBox.appendChild(roleText);
          } else if (word === "Jackal") {
          wordBox.textContent = "???";
          const roleText = document.createElement("div");
          roleText.className = "jackal-role";
          roleText.textContent = "Jackal";
          wordBox.appendChild(roleText);
          } else if (word === "Viper") {
          wordBox.textContent = "???";
          const roleText = document.createElement("div");
          roleText.className = "viper-role";
          roleText.textContent = "Viper";
          wordBox.appendChild(roleText);
        } else if (word === "Shield") {
          wordBox.textContent = secretItem;
          const roleText = document.createElement("div");
          roleText.className = "shield-role";
          roleText.textContent = "Shield";
          wordBox.appendChild(roleText);
          } else if (word === "Echo") {
          wordBox.textContent = secretItem;
          const roleText = document.createElement("div");
          roleText.className = "echo-role";
          roleText.textContent = "Echo";
          wordBox.appendChild(roleText);
          } else if (word === "Idiot") {
          wordBox.textContent = secretItem.trim().charAt(0).toUpperCase() + "...";
          const roleText = document.createElement("div");
          roleText.className = "idiot-role";
          roleText.textContent = "Idiot";
          wordBox.appendChild(roleText);
          } else if (word === "Philosopher") {
          wordBox.textContent = secretItem;
          const roleText = document.createElement("div");
          roleText.className = "philosopher-role";
          roleText.textContent = "Philosopher";
          wordBox.appendChild(roleText);
          } else if (word === "Sheriff") {
          wordBox.textContent = secretItem;
          const roleText = document.createElement("div");
          roleText.className = "sheriff-role";
          roleText.textContent = "Sheriff";
          wordBox.appendChild(roleText);
          } else if (word === "Maniac") {
          wordBox.textContent = secretItem;
          const roleText = document.createElement("div");
          roleText.className = "maniac-role";
          roleText.textContent = "Maniac";
          wordBox.appendChild(roleText);
          } else if (word === "Cultist") {
          wordBox.textContent = secretItem;
          const roleText = document.createElement("div");
          roleText.className = "cultist-role";
          roleText.textContent = "Cultist";
          wordBox.appendChild(roleText);
          } else if (word === "Shadow") {
          wordBox.textContent = "???";
          const roleText = document.createElement("div");
          roleText.className = "shadow-role";
          roleText.textContent = "Shadow";
          wordBox.appendChild(roleText);
        } else if (word === "Assassin") {
          wordBox.textContent = secretItem;
          const roleText = document.createElement("div");
          roleText.className = "assassin-role";
          roleText.textContent = "Assassin";
          wordBox.appendChild(roleText);
        } else if (word === "Clueless") {
          wordBox.textContent = cluelessWord;
        } else {
          wordBox.textContent = word; 
        }
        
        if (loverIndexes.includes(i)) {

  const partnerIndex = loverIndexes.find(x => x !== i);

  const loverText = document.createElement("div");
  loverText.className = "lovers-role";
  loverText.innerHTML = `<strong>${playerNames[partnerIndex]}</strong><br>is your Lover!`;

  wordBox.appendChild(loverText);
}
        
        if (kingPlayer === i) {
          const kingText = document.createElement("div");
          kingText.className = "king-role";
          kingText.textContent = "King";
          wordBox.appendChild(kingText);
        }


        
        wordBox.classList.add("word-revealed");
        categoryBox.textContent = "Category: " + secretCategory;
        categoryBox.classList.add("category-shown");

        // Hints
        specialHint = document.createElement("div");
        
        if (word === "Detective") {
          // --- DETECTIVE ACTIVATION LOGIC ---
          isDetectiveChoosing = true;
          activeDetectiveCardElement = card;
          card.classList.add('detective-active-card');
          document.body.classList.add('detective-mode');

          specialHint.className = "detective-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Find imposters!<br><br><strong>ACTION REQUIRED:</strong><br>Tap another player's card to investigate them!`;
          
          activeDetectiveHintElement = specialHint; // Store ref to update later

        } else if (word === "Assassin" && assassinTarget) {
          const targetName = playerNames[assassinTarget - 1] || `Player ${assassinTarget}`;
          specialHint.className = "assassin-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Get ${targetName} voted out!`;
        } else if (word === "Jester") {
          specialHint.className = "jester-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Get voted out!<br><br><strong>You can lie to the Philosopher.</strong>`;
        } else if (word === "Dictator") {
          specialHint.className = "dictator-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Survive and trick everyone!<br><br>You are able to completely <strong>remove</strong> someones vote!`;
        } else if (word === "Mastermind") {
          specialHint.className = "mastermind-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Survive and trick everyone!<br><br>You are <strong>GENIUS</strong> and deducted everyones roles!`;
        } else if (word === "Imposter") {
          specialHint.className = "imposter-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Survive and trick everyone!`;
        } else if (word === "Jackal") {
          specialHint.className = "jackal-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Survive and outlive everyone!`;
        } else if (word === "Viper") {
          specialHint.className = "viper-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Survive and outlive everyone, instead of voting you may <strong>poison</strong> people! They die by the next vote!`;
        } else if (word === "Shield") {
          specialHint.className = "shield-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Deflect your voters! Eliminate Impostor!`;
        } else if (word === "Echo") {
          specialHint.className = "echo-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Copy the person behind you! Eliminate impostor!`;
        } else if (word === "Idiot") {
          specialHint.className = "idiot-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>You're an idiot and forgot what the word is...<br>Eliminate impostor!`;
        } else if (word === "Philosopher") {
          specialHint.className = "philosopher-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Question the enemies!<br>You can ask one<br><strong> YES</strong> or<strong> NO</strong> question!`;
        } else if (word === "Sheriff") {
          specialHint.className = "sheriff-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Eliminate the impostor, by any means necessary!<br><br>You can <strong>shoot</strong> someone during a vote, don't miss!`;
        } else if (word === "Maniac") {
          // Find ANY main evil role
const realEvilIndex = words.findIndex(role =>
  mainEvilRoles.includes(role)
);

if (realEvilIndex !== -1) {
  const targetName = playerNames[realEvilIndex];

  specialHint.className = "maniac-hint";
  specialHint.innerHTML = `
    <strong>Your Mission:</strong><br>
    Help ${targetName} win, at all costs!<br><br>
    <strong>YOUR VOTE DOESN'T COUNT</strong>
  `;
}
        } else if (word === "Cultist") {
          specialHint.className = "cultist-hint";
          specialHint.innerHTML = `<strong>Your Mission:</strong><br>Find your leader and protect them at <strong>ALL</stong> costs!`;
        } else if (word === "Shadow") {

  const realEvilIndex = words.findIndex(role =>
    mainEvilRoles.includes(role)
  );

  if (realEvilIndex !== -1) {
    const targetName = playerNames[realEvilIndex];

    specialHint.className = "shadow-hint";
    specialHint.innerHTML = `
      <strong>Your Mission:</strong><br>
      Help ${targetName} win, try figure out the word!
    `;
  }
}
        if (kingPlayer === i) {
          const kingHint = document.createElement("div");
          kingHint.className = "king-hint";
          kingHint.innerHTML = `<strong>You are the King!</strong><br>You get 2 votes!`;
          card.appendChild(kingHint);
          setTimeout(() => kingHint.classList.add('show'), 10);
        }
if (loverIndexes.includes(i)) {
          const loversHint = document.createElement("div");
          loversHint.className = "lovers-hint";
          loversHint.innerHTML = `<strong>You are the Lover!</strong><br>You have a significant other!<br>Keep them safe!`;
          card.appendChild(loversHint);
          setTimeout(() => loversHint.classList.add('show'), 10);
        }

        if (specialHint.textContent) {
          card.appendChild(specialHint);
          setTimeout(() => specialHint.classList.add('show'), 10);
        }

        btn.textContent = "Close";
        statusLabel.textContent = "Revealed";
        
        if (!revealed) {
          revealed = true;
          revealedCards++;
          updateTracker();
        }
        return;
      }

      // Close Logic
      if (btn.textContent === "Close") {
        viewed = true;

        // If detective closes card without choosing, cancel the mode
        if (word === "Detective" && isDetectiveChoosing) {
          isDetectiveChoosing = false;
          document.body.classList.remove('detective-mode');
          card.classList.remove('detective-active-card');
        }

        if (specialHint) specialHint.classList.remove('show');
        const kingHint = card.querySelector('.king-hint');
        if (kingHint) kingHint.classList.remove('show');

        if (specialHint) specialHint.classList.remove('show');
        const loversHint = card.querySelector('.lovers-hint');
        if (loversHint) loversHint.classList.remove('show');

        wordBox.classList.remove("word-revealed");
        categoryBox.classList.remove("category-shown");

        setTimeout(() => {

  if (specialHint && specialHint.parentNode)
    specialHint.parentNode.removeChild(specialHint);

  if (kingHint && kingHint.parentNode)
    kingHint.parentNode.removeChild(kingHint);

  // üî• REMOVE HUNTER HINT
  const hunterHint = card.querySelector(".hunter-hint");
  if (hunterHint) hunterHint.remove();

  // üî• Also cancel hunter targeting mode if this was Hunter
  if (word === "Hunter") {
    hunterChoosingIndex = null;
  }
          
          while (wordBox.firstChild) wordBox.removeChild(wordBox.firstChild);
          
          wordBox.textContent = "Locked";
          wordBox.className = "word-box word-locked";
          btn.textContent = "Locked";
          btn.classList.add("locked");
          btn.disabled = true;
          statusLabel.textContent = "Locked";
          
          lockedCards++;

if (lockedCards === totalCards) {
  console.log("Triggering first player...");
  selectFirstPlayer();
}

          updateTracker();
        }, 250);
        setTimeout(() => {
          if (specialHint && specialHint.parentNode) specialHint.parentNode.removeChild(specialHint);
          if (loversHint && loversHint.parentNode) loversHint.parentNode.removeChild(loversHint);
          
          while (wordBox.firstChild) wordBox.removeChild(wordBox.firstChild);
          
          wordBox.textContent = "Locked";
          wordBox.className = "word-box word-locked";
          btn.textContent = "Locked";
          btn.classList.add("locked");
          btn.disabled = true;
          statusLabel.textContent = "Locked";
          
          lockedCards++;
          
          if (lockedCards === totalCards) {
  setTimeout(() => {
    selectFirstPlayer();
  }, 300);
}
          updateTracker();
        }, 250);
      }
    });

    cardsContainer.appendChild(card);
  });

  if (specialHint) {
  card.appendChild(specialHint);
  setTimeout(() => specialHint.classList.add('show'), 10);
}
}


/* ===== TOGGLE RANDOMIZE CHECKBOXES ===== */
randomizeToggle.addEventListener('change', () => {
  const isDisabled = randomizeToggle.checked;

  document.querySelectorAll('.role-pill').forEach(pill => {
    const checkbox = pill.querySelector('input[type="checkbox"]');
    if (!checkbox) return;

    checkbox.disabled = isDisabled;

    if (isDisabled) {
      pill.classList.add('disabled');
    } else {
      pill.classList.remove('disabled');
    }
  });
});

/* ===== EVENT LISTENERS ===== */
customSubjectBtn.addEventListener("click", useCustomSubject);
customSubjectInput.addEventListener("keypress", (e) => {
  if (e.key === "Enter") {
    useCustomSubject();
  }
});

changeSubjectBtn.addEventListener("click", changeSubject);
generateBtn.addEventListener("click", generateCards);
revealRolesBtn.addEventListener("click", revealAllRoles);

// Player names event listeners
resetNamesBtn.addEventListener("click", resetPlayerNames);
showPlayerNamesBtn.addEventListener("click", showPlayerNames);
hidePlayerNamesBtn.addEventListener("click", hidePlayerNames);

// Add/Remove player buttons
addPlayerBtn.addEventListener("click", addPlayer);
removePlayerBtn.addEventListener("click", removePlayer);

// Update player names when player slider changes
playerSlider.addEventListener("input", () => {
  const playerCount = parseInt(playerSlider.value, 10);
  const previousCount = playerNames.length;
  
  if (playerCount > previousCount) {
    // Add new players with default names at the end
    for (let i = previousCount; i < playerCount; i++) {
      playerNames.push(`Player ${i + 1}`);
    }
  } else if (playerCount < previousCount) {
    // Remove only the last added players (preserve early custom names)
    playerNames = playerNames.slice(0, playerCount);
  }
  
  localStorage.setItem("playerNames", JSON.stringify(playerNames));
  
  // Update player count display
  playerCountDisplay.textContent = playerCount;
  
  // Update the player names list if it's visible
  if (playerNamesSection.style.display === 'block') {
    updatePlayerNamesList();
  }
});

// Save toggle states
dictatorToggle.addEventListener("change", () => {
  localStorage.setItem("dictatorEnabled", dictatorToggle.checked);
});

mastermindToggle.addEventListener("change", () => {
  localStorage.setItem("mastermindEnabled", mastermindToggle.checked);
});

hunterToggle.addEventListener("change", () => {
  localStorage.setItem("hunterEnabled", hunterToggle.checked);
});

imposterToggle.addEventListener("change", () => {
  localStorage.setItem("imposterEnabled", imposterToggle.checked);
});


detectiveToggle.addEventListener("change", () => {
  localStorage.setItem("detectiveEnabled", detectiveToggle.checked);
});

jesterToggle.addEventListener("change", () => {
  localStorage.setItem("jesterEnabled", jesterToggle.checked);
});

jackalToggle.addEventListener("change", () => {
  localStorage.setItem("jackalEnabled", jackalToggle.checked);
});

viperToggle.addEventListener("change", () => {
  localStorage.setItem("viperEnabled", viperToggle.checked);
});

shieldToggle.addEventListener("change", () => {
  localStorage.setItem("shieldEnabled", shieldToggle.checked);
});

assassinToggle.addEventListener("change", () => {
  localStorage.setItem("assassinEnabled", assassinToggle.checked);
});

kingToggle.addEventListener("change", () => {
  localStorage.setItem("kingEnabled", kingToggle.checked);
});

loversToggle.addEventListener("change", () => {
  localStorage.setItem("loversEnabled", loversToggle.checked);
});

cluelessToggle.addEventListener("change", () => {
  localStorage.setItem("cluelessEnabled", cluelessToggle.checked);
});

echoToggle.addEventListener("change", () => {
  localStorage.setItem("echoEnabled", echoToggle.checked);
});

idiotToggle.addEventListener("change", () => {
  localStorage.setItem("idiotEnabled", idiotToggle.checked);
});

philosopherToggle.addEventListener("change", () => {
  localStorage.setItem("philosopherEnabled", philosopherToggle.checked);
});

sheriffToggle.addEventListener("change", () => {
  localStorage.setItem("sheriffEnabled", sheriffToggle.checked);
});

maniacToggle.addEventListener("change", () => {
  localStorage.setItem("maniacEnabled", maniacToggle.checked);
});

cultistToggle.addEventListener("change", () => {
  localStorage.setItem("cultistEnabled", cultistToggle.checked);
});

shadowToggle.addEventListener("change", () => {
  localStorage.setItem("shadowEnabled", shadowToggle.checked);
});


/* ===== INITIALIZATION ===== */
initializeSubjectOptions();

// Initialize player names if not already loaded
const playerCount = parseInt(playerSlider.value, 10);
if (playerNames.length === 0) {
  for (let i = 0; i < playerCount; i++) {
    playerNames.push(`Player ${i + 1}`);
  }
  // Save default names to localStorage
  localStorage.setItem("playerNames", JSON.stringify(playerNames));
}

// Initialize player count display
playerCountDisplay.textContent = playerCount;

if (currentSubject) {
  showSelectedSubject();
  enableGenerateButton();
} else {
  generateBtn.disabled = true;
  generateBtn.textContent = "Select Subject First";
}

// Initialize the show player names button visibility
showPlayerNamesBtn.style.display = 'block';
playerNamesSection.style.display = 'none';

// Single event listener for the hide button
hidePlayerNamesBtn.addEventListener('click', () => {
  playerNamesSection.style.display = 'none';
  showPlayerNamesBtn.style.display = 'block';
});

// Single event listener for the show button
showPlayerNamesBtn.addEventListener('click', () => {
  playerNamesSection.style.display = 'block';
  showPlayerNamesBtn.style.display = 'none';
  updatePlayerNamesList();
});

// AI Modal Listeners
closeAiModalBtn.addEventListener('click', closeAiModal);
cancelAiBtn.addEventListener('click', closeAiModal);
generateAiBtn.addEventListener('click', generateAiSubject);
aiTopicInput.addEventListener('keypress', (e) => {
  if (e.key === "Enter") generateAiSubject();
});
aiModalOverlay.addEventListener('click', (e) => {
  if (e.target === aiModalOverlay) closeAiModal();
});
updateRoleVisuals();

document.querySelectorAll('.role-pill input[type="checkbox"]').forEach(cb => {
  cb.addEventListener("change", () => {
    updateRoleAvailability();
    updateRoleVisuals();
  });
});

// initialize once
updateRoleAvailability();
updateRoleVisuals();

</script>
<div id="shieldFlashOverlay"></div>
</body>
</html>